<?xml version="1.0" encoding="UTF-8"?>
<CTHeader webcompat="0" proc_error_correction="0" xRayProject="0" revision="$Id: CTHeader.cpp,v 1.31 2011-03-03 16:22:03 stefanh Exp $" text_recognition_methods="glyphmaps,ocr" profile_language="eng">
    <Header threshold="0.810000">
        <PageID>
            <Attributes>
                <HTML3 value="title,url"/>
                <HTML3PagKeyCalls>
                    <title FunName="DgoProfile.get_title"/>
                    <url FunName="DgoUtils.get_url"/>
                </HTML3PagKeyCalls>
            </Attributes>
        </PageID>
        <ContextID object_attribute="" context_attribute_name="" rule="0"/>
        <Ident classname="" exename="iexplore,chrome" urls="" version="" caption=""/>
    </Header>
    <Global min_w="-1" min_h="-1" max_w="-1" max_h="-1">
        <SAP recursion_level="3" has_context_info="1" find_embedded="0" access_check="0"/>
        <JAVA use_jab_watcher="1" jab_tab_lookuplevel="3" jab_tree_lookuplevel="3" enable_jab_button_handler="1" jab_rerecognition_use_name="1" max_sl_edit_jab_height="0" init_with_setpage="0" jab_generate_path="1" java_rere_use_empty_name="1" java_use_fast_path="1" access_check="0"/>
        <MSAA generate_path="1" max_name_objs="0" msaa_tab_lookuplevel="3" msaa_tree_lookuplevel="3" rerecognition_use_names="0">
            <ObjectCorrections>
                <ObjectCorrection id="42" classname="Internet Explorer_Server" action="1">
                    <CorrectControls value="17,29,30,37,40,44,45,46,47,53,56,57,58,61,62,64"/>
                </ObjectCorrection>
            </ObjectCorrections>
        </MSAA>
        <UIAutomation uia_tab_lookuplevel="3" uia_tree_lookuplevel="3" unique_ids="0" rerecognition_use_names="1" uia_generate_path="1" max_name_objs="0"/>
        <UIACOM caching="0" generate_path="1" max_name_objs="200"/>
        <HTML handle_zoom="1" has_context_info="0" batch_rerecognition="0" pgkey_fback="0" set_attrb="0" capture_multiple_dlg="0" ignore_dynamic_ids="1">
            <GlobalScript/>
        </HTML>
        <HTML3 handle_zoom="1" has_context_info="1" has_product_info="0" batch_rerecognition="1" capture_multiple_dlg="0" rlevel="0" ignore_dynamic_ids="0" is_xray_profile="0">
            <GlobalScript>
// include file: ../common/common_script.js

var elem_index_within_frame = -1;
var rerecognized_frame = null;
var current_rerecognition_elem_index = -1;
var capture_multi_dlg = false;
var pagtab_attr = "";
var ignore_dynamic_ids = 1;
var ignore_ids = false;
var xray_project = false;
var wpb_system = "";

// Internet Explorer
var dgo_webcompat = false;
var dgo_zoomlevel = 100;
var dgo_ie_version = -1;
var eep_useInnerText = ":A:TD:SPAN:NOBR:LABEL:STRONG:FONT:B:U:DIV:";

function exception_debugging(e) {
    //alert("exception_debugging:\nName: " + e.name + " Description: " + e.description + "\n\n" + e.stack);//
}

// functions called from processor
// IEBrowser::set_ie_info_
function dgo_set_ie_info(ie_info) {
    return DgoProcessing.set_ie_info(ie_info);
}
// IEBrowser::get_element_info_from_script_
function recognition_process(point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
    return DgoProcessing.recognition_process(point_x, point_y,
        frame_path, gen_path,
        top_frame_left, top_frame_top);
}
// IEBrowser::GetPointRect
function get_cntrl_rect(point_x, point_y, top_frame_left, top_frame_top) {
    return DgoProcessing.get_cntrl_rect(point_x, point_y, top_frame_left, top_frame_top);
}
// IEBrowser::get_rere_script_ (cnltr_search_on_same_level_, process_path_from_script_)
function rerecognition(eepInput, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
    return DgoProcessing.rerecognition(eepInput, obj_type, check_names,
        rere_frame_offset_x, rere_frame_offset_y);
}
//IEBrowser::execute_on_frame_
function batch_rerecognition(multipaths, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
    return DgoProcessing.batch_rerecognition(multipaths, obj_type, check_names,
        rere_frame_offset_x, rere_frame_offset_y);
}
// IEBrowser::exec_script_
function get_system_name() {
    return DgoProcessing.get_system_name();
}
// IEBrowser::GetExpandedRect
function get_control_parent_offset(e, par_level) {
    return DgoProcessing.get_control_parent_offset(e, par_level);
}
// IEBrowser::get_cntxt_script_ (get_cntxt_attr_)
function GetContextAttributes() {
    return DgoProcessing.get_context_attributes();
}
// IEBrowser::resolve_eep_
//function Eep_resolve(eepString, options, check_names) { // HTMLProcessor version 2
//    try {
//        var eep_resolveOptions = {
//            eep_first_text_re: null,
//            eep_use_text: check_names,
//            eep_version: "6.1.1"
//        };
//        var eep = DgoEep(eepString, eep_resolveOptions);
//        var obj = eep.eep_resolve();
//        return (typeof obj === "object" ? obj : null);
//    } catch (err) { }
//    return null;
//}
function Eep_resolve3(eepString, options, check_names) { // HTMLProcessor version 3
    return DgoProcessing.eep_resolve3(eepString, options, check_names);
}
// IEBrowser::set_value_
function dgo_set_value(e, val) {
    return DgoProfile.set_value(e, val);
}
// IEBrowser::get_value_
function dgo_get_value(e) {
    return DgoProfile.get_value(e);
}
// IEBrowser::get_page_attr_ - profile specific
// get_active_tree_item
// get_active_page_tab
// get_active_page_tab_level2
// legacy
function dgo_standard_fieldname(e) {
    return DgoProfile.standard_fieldname(e);
}
function dgo_button_name(e) {
    return DgoProfile.button_name(e);
}
function dgo_inner_text(e) {
    return DgoProfile.inner_text(e);
}
function dgo_fieldname_finder(e) {
    return DgoProfile.fieldname_finder(e);
}
function dgo_font_size(e) {
    return DgoProfile.font_size(e);
}
function dgo_font_family(e) {
    return DgoProfile.font_family(e);
}
function dgo_font_color(e) {
    return DgoProfile.font_color(e);
}
function dgo_bg_color(e) {
    return DgoProfile.bg_color(e);
}

function dgo_get_state(e) {
    return DgoProfile.get_state(e);
}
function dgo_set_state(e, s) {
    return DgoProfile.set_state(e, s);
}
function dgo_get_INPUTradio_or_INPUTcheckbox_fieldname(e) {
    return DgoProfile.get_INPUTradio_or_INPUTcheckbox_fieldname(e);
}
function dgo_RADIO_fieldname(e) {
    return DgoProfile.RADIO_fieldname(e);
}
function dgo_get_combo_button_fieldname(e) {
    return DgoProfile.get_combo_button_fieldname(e);
}
function dgo_SAP_Web_checkbox_state(e) {
    return DgoProfile.SAP_Web_checkbox_state(e);
}
// =====================================================================================
// ====================================== Profile ======================================
// =====================================================================================
var DGO = window.DGO || {};

function extendObj(dst, src) {
    for (var i in src) {
        if (src.hasOwnProperty(i)) dst[i] = src[i];
    }
}
// =================================== Processing functions =================================== //
DGO.BaseProcessing = function () { };
DGO.BaseProcessing.prototype = {
    set_ie_info: function (ie_info) {
        try {
            ie_info = DgoProfile.extract_info_from_string(ie_info, "IEinfo", "={", ";");
            var ie_info_map = DgoProfile.convert_from_string_to_map(ie_info, ",");
            if (ie_info_map.IEversion) dgo_ie_version = parseInt(ie_info_map.IEversion);
            if (ie_info_map.Webcompat) {
                if ("true" === ie_info_map.Webcompat) dgo_webcompat = true;
            }
            if (typeof ie_info_map.CaptureMultipleDlg !== "undefined") {
                if (ie_info_map.CaptureMultipleDlg === "1") capture_multi_dlg = true;
            }
            if (typeof ie_info_map.IgnoreDynamicIds !== "undefined") {
                ignore_dynamic_ids = Number(ie_info_map.IgnoreDynamicIds);
            }
            return true;
        } catch (err) {
            exception_debugging(err);
        }
        return false;
    },
    recognition_process: function (point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
        try {
            var html_rec_obj = HTMLElementRecognition;//new HTMLElementRecognition();
            html_rec_obj.check_input();
            html_rec_obj.init(point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top);
            try {
                if (!html_rec_obj.get_element_from_point(point_x, point_y)) {
                    return "";
                }
            } catch (err) { exception_debugging(err); }
            if (html_rec_obj.element === null) return "";

            html_rec_obj.get_element_path();
            html_rec_obj.get_bc_rect();
            //if (html_rec_obj.gen_path === 1) {
            html_rec_obj.get_element_eep();
            //}
            html_rec_obj.element_rect_str = html_rec_obj.execute_self_handler(point_x, point_y, html_rec_obj.element);
            DgoProfile.element_rect = html_rec_obj.element_rect;
            html_rec_obj.object_type = html_rec_obj.object_sub_type ? html_rec_obj.object_sub_type : DgoProfile.elem_xtype(html_rec_obj.element);

            //html_rec_obj.object_type = DgoProfile.elem_xtype(html_rec_obj.element) + html_rec_obj.object_sub_type;
            if (typeof html_rec_obj.element.tagName !== "undefined") {
                return html_rec_obj.recognition_output()/* +"|@|"+ html_rec_obj.get_cnlt_props()*/;
            }
        } catch (err) {
            exception_debugging(err);
            return err.name + "," + err.description + "," + err.number;
        }
        return "";
    },
    get_cntrl_rect: function (point_x, point_y, top_frame_left, top_frame_top) {
        var obj_rect = "";
        try {
            var html_rec_rect = HTMLElementRecognition;//new HTMLElementRecognition();
            html_rec_rect.check_input();
            html_rec_rect.init(point_x, point_y, "", 0, top_frame_left, top_frame_top);
            html_rec_rect.get_element_from_point(point_x, point_y);
            if (!html_rec_rect.element) return "";

            html_rec_rect.get_bc_rect();
            html_rec_rect.element_rect_str = html_rec_rect.execute_self_handler(point_x, point_y, html_rec_rect.element);
            if (typeof html_rec_rect.element.tagName !== "undefined") {
                if (html_rec_rect.object_sub_type === "") {
                    var r = html_rec_rect.element_rect;
                    obj_rect = parseInt(r.left) + "," + parseInt(r.top) + "," + parseInt(r.right) + "," + parseInt(r.bottom);
                } else {
                    obj_rect = html_rec_rect.element_rect_str;
                }
            }
        } catch (err) {
            exception_debugging(err);
            return err.name + "," + err.description + "," + err.number;
        }
        return obj_rect;
    },
    rerecognition: function (eepInput, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
        try {
            rerecognition_frame_offset_x = rere_frame_offset_x;
            rerecognition_frame_offset_y = rere_frame_offset_y;
            var html_rerec_obj = HTMLElementRerecognition;//new HTMLElementRerecognition();
            if (!html_rerec_obj.check_input(eepInput)) return "";
            html_rerec_obj.init(eepInput, obj_type, check_names);
            if (html_rerec_obj.get_elem_from_index_path()) {
                if (DgoProfile.is_obj_hidden(html_rerec_obj.element)) return 2;
                if (html_rerec_obj.element_path === "") html_rerec_obj.get_element_path();
                html_rerec_obj.get_rect();
                DgoProfile.element_rect = html_rerec_obj.element_rect;
                html_rerec_obj.object_type = html_rerec_obj.object_sub_type ? html_rerec_obj.object_sub_type : DgoProfile.elem_xtype(html_rerec_obj.element);
                return html_rerec_obj.rerecognition_output();
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    batch_rerecognition: function (multipaths, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
        var ret_val = "";
        try {
            var elements = DgoProfile.string_to_map_of_map(multipaths, "|PP|", "|PT|");
            var count = elements.length;
            for (var iter = 0; iter &lt; count; iter++) {
                var ret_status = this.rerecognition(elements[iter][0], elements[iter][1], check_names, rere_frame_offset_x, rere_frame_offset_y);
                if (iter != 0) {
                    ret_val = ret_val + "|+|" + ret_status;
                } else {
                    ret_val = ret_status;
                }
            }
        } catch (err) { exception_debugging(err); }
        return ret_val;
    },
    get_system_name: function () { // dummy
        return false;
    },
    get_control_parent_offset: function (e, par_level) {
        var elem = e;
        var fn = "";
        var level = Number(par_level);
        var r_elem = elem.getBoundingClientRect();
        var parent = elem.parentNode;
        for (var iter = 1; iter &lt; level; iter++) {
            if (parent &amp;&amp; parent.parentNode) parent = parent.parentNode;
        }
        if (parent) {
            var p_elem = parent.getBoundingClientRect();
            fn = (parseInt(r_elem.left) - parseInt(p_elem.left)) + "," + (parseInt(r_elem.top) - parseInt(p_elem.top)) + "," +
                (parseInt(p_elem.right) - parseInt(r_elem.right)) + "," + (parseInt(p_elem.bottom) - parseInt(r_elem.bottom));
        }
        return fn;
    },
    get_context_attributes: function () {
        // Systems = SAP Portal ,SAPGUI for HTML, LSO, CRM, NWBC and NW Enterprise Portal.
        // Return value = Context IDs.
        window.document.body.setAttribute("cntxt_attrs", "", 0);
        try {
            var attrs = DgoProfile.get_parent_system_context_attributes() + DgoProfile.get_child_system_context_attributes();
            if (DgoUtils.is_valid_str(attrs)) return attrs;
            if (TitleContextMap.length) return DgoProfile.cntxt_conf_param_from_TitleContextMap();
        } catch (err) { exception_debugging(err); }
        return "";
    },
    eep_resolve3: function (eepString, options, check_names) {
        var ref_path = "";
        try {
            var eep_resolveOptions = {
                eep_first_text_re: null,
                eep_use_text: check_names,
                eep_version: "6.1.1"
            };
            var eep = DgoEep;
            eep.init(eepString, eep_resolveOptions);
            var obj = eep.eep_resolve();
            if (obj) {
                var tag_coll = window.document.getElementsByTagName(obj.tagName);
                if (tag_coll) {
                    var tag_coll_length = tag_coll.length;
                    for (var i = 0; i &lt; tag_coll_length; i++) {
                        var child = tag_coll.item(i);
                        if (obj === child) {
                            //ref_path = 'window.document.all.tags("' + obj.tagName + '")' + '[' + i + ']'; // document.all deprecated in IE11
                            ref_path = "window.document.getElementsByTagName(\"" + obj.tagName + "\")" + "[" + i + "]";
                            break;
                        }
                    }
                }
            }
            //return typeof obj === "object" ? Eep_getPathString(obj, options_) : "";
        } catch (err) { exception_debugging(err); }
        return ref_path;
    }
};
// ====================================== Base functions ====================================== //
DGO.Base = function () { };

DGO.Base.prototype = {
    check_handler: function (type) {
        var valid_tags = [
            // basic html
            "A",
            "DIV",
            "INPUTbutton", "INPUTpassword", "INPUTradio", "INPUTcheckbox", "INPUTcheckboxOn", "INPUTcheckboxOff", "INPUTtext", "INPUTsubmit",
            "IMGA:", "IMGSPAN:",
            "SPAN", "SELECT",
            "TEXTAREA",
            // common
            "AorderItem", "AindexLink", "ApushButton",
            "AWebguiActiveButton", "AWebguiIconTextButton2002", "AWebguiIconTextButton", "AwebguiMetaMenu",
            "BODY",
            "DIVNewMenuItemHilited", "DIVNewMenuItem", "DIVCalT", "DIVCTLink",
            "HTML",
            "IMGA:advClearButton", "IMGA:WebguiActiveIconButton", "IMGA:WebguiIconTextButton",
            "IMGDIVGridView_MenuButton", "IMGDIVwebguiSearchHelpButton", "IMGDIVwebguiTCSearchHelpButtonfixed", "IMGDIVwebguiTCSearchHelpButton",
            "IMGSPAN:hTBCButtonEnabledUnchecked", "IMGSPAN:WebguiToolbarIconEnabled:f_canc", "IMGSPAN:WebguiToolbarIconEnabled:f_back",
            "IMGSPAN:WebguiToolbarIconEnabled:f_okay", "IMGSPAN:WebguiToolbarIconEnabled:f_endt", "IMGSPAN:WebguiToolbarIconEnabled:f_save",
            "IMGSPAN:WebguiToolbarIconEnabled", "IMGSPANColumnTreeExpOpen:CTLink", "IMGSPANColumnTreeExpClose:CTLink",
            "IMGTDTX_XS", "IMGTDTCSelImageUnselected", "IMGTDTCTopPageA", "IMGTDTCLastPageA", "IMGTDTCPrevPageA", "IMGTDTCNextPageA",
            "IMGTDTCPrevRowA", "IMGTDTCNextRowA", "IMGTDTCSelImageSelected", "IMGTDWebguiModalTitleBarXA", "IMGTDWebguiModalTitleBarXI",
            "IMGTDGridViewMarkAllHeader", "IMGTDPULLDOWN-TABSTRIP", "IMGTDwebguiTSForwardA", "IMGTDwebguiTSBackA", "IMGTDwebguiMetaMenu",
            "IMGTDListItem-open", "IMGTDListItem-closed", "IMGTDListItem-leaf", "IMGTDWebguiMessageLine",
            "IMGTDINPUTX", "IMGTDINPUT",
            "INPUTtextplusvalue",
            "OpenValueHelp",
            "SAP_EA_Menu",
            "SPANnoneditinputHighlighted", "SPANnoneditinput", "SPANsapEdfTxtEnbl sapEdfSpanEnbl", "SPAN:urTrcTitHdr",
            "SPANWebguiStatusBarFont", "SPANCTLink", "SPANlabelTable", "SPANlsButton__text urBtnCntTxt", "lsButton__text urBtnCntTxt lsButton--overflow",
            "TDwebguiTSTextDesel", "TDVSlider", "TDListItem", "TDalvc", "TDCalM", "TDWebguiMessageLine", "TDNewMenuCaption",
            "TDNewMenuItemFont", "TDpushButton", "TDsearchHelpResultBody", "THTCColumnTitleSelectable", "DIVWorkcenterStandard", "DIVTabText",
            "IMGAurImgBtn:urBtnStd", "SPAN:urBtnStd"
        ];
        return DgoUtils.is_in_array(type, valid_tags);//valid_tags.indexOf(type) &gt;= 0;
    },
    convert_to_compat: function (type) {
        switch (type) {
            case "INPUTsubmit":
            case "SPANlsButton__text urBtnCntTxt":
            case "lsButton__text urBtnCntTxt lsButton--overflow":
                return "INPUTbutton";
            case "SPAN":
                return "A";
            case "ApushButton":
            case "AindexLink":
                return "AWebguiActiveButton";
            case "IMGA:advClearButton":
            case "IMGA:WebguiActiveIconButton":
                return "IMGA:";
            case "IMGSPAN:hTBCButtonEnabledUnchecked":
                return "IMGSPAN:";
            case "IMGSPAN:WebguiToolbarIconEnabled:f_endt":
                return "IMGSPAN:WebguiToolbarIconEnabled:f_canc";
            case "IMGTDINPUT ":
            case "IMGSPANurImgCbgImg urV:urImgCbgWhl1":
                return "IMGTDINPUT";
            case "INPUTtexturBorderBox lsEdf2HlpRadius lsEdf3HlpBtn lsEdf3HlpBtnDate urEdfVAlign lsEdf3HlpBtnFocus":
            case "INPUTtexturBorderBox lsEdf2HlpRadius lsEdf3HlpBtn lsEdf3HlpBtnDate urEdfVAlign lsEdf3HlpBtnHv lsEdf3HlpBtnHvDate":
                return "INPUTtexturBorderBox lsEdf3HlpBtn lsEdf3HlpBtnDate";
            case "IMGSPANurNoUserSelect urCImgOn urCImgOnHover:urCLbl urCl1 ":
            case "IMGSPANurNoUserSelect urCImgOff lsCWhlTbl urCImgOffHover:urCLbl":
                return "INPUTcheckboxOff";
            case "SPANnoneditinputHighlighted":
            case "SPANnoneditinput":
                return "TDsearchHelpResultBody";
            case "IMGTDTCSelImageSelected":
            case "TDGridViewMarkCell":
                return "IMGTDTCSelImageUnselected";
            case "IMGTDWebguiModalTitleBarXI":
                return "IMGTDWebguiModalTitleBarXA";
            case "TDwebguiTSTextDesel":
            case "AWebguiIconTextButton":
            case "AwebguiMetaMenu":
            case "TDtext":
                return "DIVNewMenuItemHilited";
            case "DIVCalT":
            case "DIVurHSpcLrg urHSpcStdImg":
            case "SPANurCLbl urCl1":
            case "DIVnavIcon":
                return "TDCalM";
            case "IMGTD":
            case "TDth-cal-arr-next":
            case "DIVsapUiSearchFieldIco":
            case "SPANIconArrowOpen textIcon":
                return "TDnavPanExpIco";
            case "Ath-menu-link":
            case "SPANlsMenuItemHover":
                return "SPANurMenuItemTxtStdHover";
            case "INPUTtextth-if th-if-icon th-ip-onfocus":
            case "INPUTtexturCoB2TxtDdl lsEdf3TxtHlpBtn":
            case "INPUTtexturEdf2TxtRadius urEdf2TxtEnbl urEdf2TxtMono lsEdf3TxtHlpBtn lsEdfLeftBrdRadius urEdf2TxtHv":
            case "INPUTtexturEdf2TxtEnbl lsEdf3TxtHlpBtn lsEdfLeftBrdRadius urEdf2TxtWarn urEdf2TxtHv":
                return "INPUTtextth-if th-if-icon";
            case "TDurSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl":
            case "Ath-hover-item-text-on":
                return "SPANth-dym-span th-dym-text";
            case "DIVCTLink":
                return "SPANCTLink";
            case "IMGTDurPcExpOpenIco":
            case "DIVOverflowBtn oHover":
                return "IMGTDurPcMenuIcoAll";
            case "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4":
            case "SPANsapEdfHlpF4":
                return "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4 lsEdf3HlpBtnHv";
            case "SPANsapETbvBtnPgDown":
                return "SPANsapETbvBtnDown";
            case "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeCol sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeExp sapUiBtnStd":
            case "IMGAurImgBtn:urNoUserSelect urBtnRadius  urBtnStdWithImg  urBtnStdMnuOnlyImg  urBtnImgBgColor urBtnStd":
            case "IMGAurImgBtn:urBtnStd":
            case "SPAN:urBtnStd":
                return "IMGAurImgBtn:urNoUserSelect urBtnRadius  urBtnStdValign  urBtnStdWithImg  urBtnStdMnuOnlyImg  urBtnImgBgColor urBtnTglStd urBtnStd";
            case "IMGAurBtnMnuIco urBtnMnuIcoHover:urNoUserSelect urBtnRadius  urBtnStdValign urBtnStd":
            case "IMGAurBtnMnuIco:urNoUserSelect urBtnRadius  urBtnStdValign urBtnStd":
                return "SPANth-bt-span";
            case "ACAL_XXS_WEKND":
                return "ACAL_XXS_MAIN";
            case "INPUTtexturEdf2TxtEnbl":
            case "INPUTtexturEdf2TxtEnbl urEdf2TxtHlp":
                return "TDurST3TD urCursorClickable urST3Cl";
            case "Anwbc-HierarchicalBrowserFolderItem":
                return "SPANnwbc-HierarchicalBrowserFolderFolderText";
            default:
                return type;
        }
    },
    elem_xtype: function (e) {
        if (!e) return "";
        var elem = e;
        var tagname = elem.tagName;
        var class_name = elem.className;
        var type = tagname;
        var parent = elem.parentNode;
        var parentcn = parent.className;
        var parenttag = parent.tagName;
        var ntype;

        //if (["B", "U", "EM", "NOBR", "STRONG", "FONT"].indexOf(type) &gt;= 0) {
        if (DgoUtils.is_in_array(type, ["B", "U", "NOBR", "STRONG", "FONT"])) {
            if (parent !== null) {
                elem = parent;
                type = elem.tagName;
            }
        }

        switch (type) {
            case "INPUT":
                type += elem.type;
                tagname = type;
                if (type === "INPUTimage") {
                    ntype = type + "/" + elem.id;
                    type += this.check_handler(ntype) ? "/" + elem.id : "/";
                }
                if (type === "INPUTimage/") {
                    ntype = type + "/" + parent.id;
                    type += this.check_handler(ntype) ? "/" + parent.id : "/";
                }
                if (type === "INPUTtext") type += class_name;
                break;
            case "IMG":
                type += parent.tagName;
                switch (type) {
                    case "IMGA":
                    case "IMGSPAN":
                        type += class_name + ":" + parentcn;
                        if (type === "IMGSPAN:WebguiToolbarIconEnabled") {
                            type += ":" + parent.id;
                            if (this.check_handler(type)) type = "IMGSPAN:WebguiToolbarIconEnabled";
                        }
                        break;
                    case "IMGLABEL":
                        type += class_name;
                        break;
                    case "IMGTD":
                        type += class_name;
                        if (type === "IMGTD") type += parentcn;
                        var prev_sibling = elem.previousSibling;
                        if (type === "IMGTD" &amp;&amp; prev_sibling !== null) type += prev_sibling.tagName;
                        if (type === "IMGTDINPUT" &amp;&amp; prev_sibling !== null) type += prev_sibling.value;
                        if (type.match("IMGTDListItem*")) {
                            type = "IMGTDListItem";
                            var img = elem.href;
                            if (img.match("list.*2_5.*")) {
                                type += "-open";
                            } else if (img.match("list.*2_4.*")) {
                                type += "-closed";
                            } else if (img.match("list.*1_0.*")) {
                                type += "-leaf";
                            }
                            if (type === "IMGTDListItem") type = "IMGTDListItem-leaf"; // assume leaf for everything else
                        }
                        break;
                    case "IMGDIV":
                        if (type === "IMGDIV") type += class_name;
                        if (type === "IMGDIV") type += parentcn;
                        if (type === "IMGDIV") type += parent.id;
                        // Wertehilfe ist etwas anders in tabs und popups
                        if (type.match("IMGDIVwebguiTSSHButton.*") || type.match("IMGDIVwebguiConSHButton.*")) {
                            type = "IMGDIVwebguiSearchHelpButton";
                        }
                        break;
                    case "IMGLABEL":
                        type += class_name;
                        if (type === "IMGLABEL") type += parentcn;
                        break;
                }
                break;
            case "TD":
                type += class_name;

                if (type.match("TDListItem*")) {
                    type = "TDListItem";
                } else if (type.match("TDalvc.*")) {
                    type = "TDalvc";
                } else if (type.match("TDVSlider-*")) {
                    type = "TDVSlider";
                } else if (type.match("TDCalM.*")) {
                    type = "TDCalM";
                } else if (type.match("lsItemlistbox*")) {
                    type = "TDListItem";
                }

                // for TDsearchHelpResultBody
                if (type === "TD") type += parent.parentNode.parentNode.id;
                break;
            case "A":
                type += parentcn === "nwbc-HierarchicalBrowserFolderItem" ? parentcn : class_name;
                break;
            case "DIV":
                type += class_name;
                if (type === "DIV") {
                    if (elem.currentStyle) {
                        type += elem.currentStyle.overflow;
                    }
                } else if (-1 !== type.search("HlpBtnCoB")) {
                    type = "INPUTtexturCoB2Btn";
                } else {
                    var id = elem.id;
                    if (-1 !== id.search("menu")) {
                        type = "SPANbutton_title";
                    }
                }
                break;
            case "SPAN":
                var focus_class = "";
                if (class_name) {
                    type += class_name;
                } else if ((typeof elem.downclass !== "undefined" &amp;&amp; (focus_class = elem.downclass)) ||
                           (typeof elem.hoverclass !== "undefined" &amp;&amp; (focus_class = elem.hoverclass))) {
                    type += focus_class;
                }
                if (type.match("SPANCTLink.*")) {
                    type = "SPANCTLink";
                } else if (type === "SPAN") {
                    type += ":" + parentcn;
                }
                break;
            case "LABEL":
            case "EM":
            case "H2":
            case "LI":
            case "P":
            case "TH":
            case "BUTTON":
                type += class_name;
                break;
            case "BODY":
                if (typeof elem.contentEditable !== "undefined" &amp;&amp; elem.contentEditable === "true") type = "INPUTtexturPagerInput";
                break;
        }

        // do distinguish between SPANurTxtStd in certain TD from SPANurTxtStd in other or none TDs
        if (type === "SPANurTxtStd") {
            if (parentcn === "urSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl") {
                type = "SPANurTxtStd_TDurSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl";
            }
        }
        // to identify a checked checkbox
        if (type === "IMGLABELurCImgOn") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOn";
        }
        // to identify a unchecked checkbox
        if (type === "IMGLABELurCImgOff") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOff";
        }

        // InputFields in certain TDs for correct rect and fieldname
        if (type === "INPUTtexturEdf2TxtEnbl") {
            if (parenttag === "TD") type = "INPUTurEdf2TxtEnbl_in_TD";
        }
        type = DgoUtils.trim(type);
        if (type === "IMGAth-ip-img:th-ip-h" &amp;&amp; parent.title &amp;&amp; (-1 !== parent.title.search("Open Input Help"))) {
            type = "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4 lsEdf3HlpBtnHv";
        }

        // fallback to tagname if no special entry found
        if (!this.check_handler(type)) {
            switch (tagname) {
                case "A":
                case "BUTTON":
                case "OPTION":
                case "INPUTtext":
                case "TEXTAREA":
                case "DIV":
                    type = tagname;
                    break;
                case "IMG":
                    type = "IMGA:";
                    break;
                case "SPAN":
                    type = "A";
                    break;
                case "BODY":
                case "HTML":
                    break;
                default:
                    type = "A";
                    break;
            }
        }

        type = this.convert_to_compat(type);
        //alert(type);
        //alert(e.outerHTML);
        return type;
    },
    get_info: function (e) {
        var l = 0;
        var t = 0;
        var c = e;
        var txt = "";

        if (e.tagName != "SELECT") txt = e.innerText;

        while (c &amp;&amp; typeof c.offsetLeft !== "undefined") {
            l += c.offsetLeft;
            t += c.offsetTop;
            c = c.offsetParent;
        }

        return { l: l, t: t, w: e.offsetWidth, tag: e.tagName, text: txt };
    },
    get_fn: function (e, x_item, y_item, w_item, flag) {
        if (e === null) return null;

        var s_label = this.get_info(e);
        var fn = s_label.text;
        if (typeof fn === "undefined" || fn === "" || fn === " ") return null;

        var x_label = s_label.l;
        var y_label = s_label.t;
        //var tag = s_label.tag;

        if (typeof flag !== "undefined" &amp;&amp; flag === "right") {
            if (x_item &gt; x_label) return null;
        } else if (x_item &lt; x_label) {
            return null;
        } else if (x_label &gt; 10 + x_item + w_item) {
            return null;
        }

        if (y_label &gt; y_item + 18) return null;
        //if (tag === "SELECT")  return null;

        if (fn.charAt(0) === "*") fn = fn.substr(1);
        if (fn.substr(fn.length - 1, 1) === ":") fn = fn.substr(0, fn.length - 1);
        fn = fn.fast_trim();
        return this.valid_string(fn) &amp;&amp; isNaN(fn)
            ? fn
            : null;
    },
    check_rect_boundry_conditions: function (e, fn_e, flag) {
        if (!this.check_element(fn_e)) return false;
        try {
            var r_e = e.getBoundingClientRect();
            var r_fn_e = fn_e.getBoundingClientRect();
            var h_e = (parseInt(r_e.bottom) - parseInt(r_e.top));
            var h_fn_e = (parseInt(r_fn_e.bottom) - parseInt(r_fn_e.top));

            if (flag === "left" &amp;&amp; (parseInt(r_fn_e.right) &lt;= parseInt(r_e.right)) &amp;&amp; ((h_e * 3) &gt; h_fn_e)) {
                return true;
            }
            if (flag === "top" &amp;&amp; (parseInt(r_fn_e.bottom) &lt;= parseInt(r_e.top))) {
                return true;
            }
            if (flag === "right" &amp;&amp; (parseInt(r_e.right) &lt;= parseInt(r_fn_e.left)) &amp;&amp; ((h_e * 3) &gt; h_fn_e)) {
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_fn_from_pos: function (doc, start_x, start_y, delta_x, delta_y, iterations, s_item, e, flag) {
        if (doc === null) return null;
        var fn = null;
        var it = 0;
        var fn_e = null;
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;

        do {
            fn_e = doc.elementFromPoint(start_x, start_y);
            if (fn_e &amp;&amp; !this.is_valid_control_tagname(fn_e) &amp;&amp; this.is_valid_fn_element(fn_e, flag)) {
                if (this.check_rect_boundry_conditions(e, fn_e, flag)) {
                    fn = this.get_fn(fn_e, x_item, y_item, w_item, flag);
                    if (!this.is_valid_fieldname(fn)) fn = "";
                }
            }

            try {
                if (fn_e &amp;&amp; (fn_e.tagName === "INPUT") &amp;&amp; (fn_e.type === "text") &amp;&amp; (flag === "left")) {
                    var rect = fn_e.getBoundingClientRect();
                    if (rect) {
                        start_x = parseInt(rect.left) - 5;
                    }
                }
            } catch (err) { exception_debugging(err); }

            start_x += delta_x;
            start_y += delta_y;

            it++;
        } while (fn_e !== null &amp;&amp; !this.valid_string(fn) &amp;&amp; start_x &gt; 0 &amp;&amp; start_y &gt; 0 &amp;&amp; it &lt; iterations);

        if ((e.tagName === "TEXTAREA") &amp;&amp; fn_e &amp;&amp; fn_e.children &amp;&amp; (fn_e.children.length &gt; 1)) {
            return "";
        }
        return this.valid_string(fn) ? fn : null;
    },
    get_doc_from_elem: function (e) {
        if (!e) return null;
        try {
            if (typeof e.document !== "undefined") return e.document;
            if (typeof e.ownerDocument !== "undefined") return e.ownerDocument;
        } catch (err) { exception_debugging(err); }
        return null;
    },
    get_elem_offset: function (e) {
        var l = 0;
        var t = 0;
        //var my_e = e;
        //var doc = window.document;
        var r = e.getBoundingClientRect();

        l = parseInt(r.left);
        t = parseInt(r.top);

        return { l: l, t: t };
    },
    get_fn_from_left_if_cnlt_present: function (e, no_of_times_travers) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var fn = "";
        var elem_offset = this.get_elem_offset(e);
        var s_item = this.get_info(e);
        var it = 0;
        var fn_e = null;
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;
        var start_x = elem_offset.l - 10;
        var start_y = elem_offset.t + e.offsetHeight / 2;
        var delta_x = -10;
        var delta_y = 0;
        do {
            fn_e = doc.elementFromPoint(start_x, start_y);
            if (fn_e &amp;&amp; fn_e.tagName === "INPUT" &amp;&amp; fn_e.type === "text") {
                var rect = fn_e.getBoundingClientRect();
                start_x = parseInt(rect.left);
                start_y = parseInt(rect.top) + (parseInt(rect.bottom) - parseInt(rect.top)) / 2;
            }
            if (fn_e &amp;&amp; this.check_rect_boundry_conditions(e, fn_e, "left")) {
                fn = this.get_fn(fn_e, x_item, y_item, w_item, "left");
                if (!this.is_valid_fieldname(fn)) fn = "";
            }
            start_x += delta_x;
            start_y += delta_y;
            it++;
        } while (fn_e !== null &amp;&amp; !this.valid_string(fn) &amp;&amp; (start_x &gt; 0) &amp;&amp; (start_y &gt; 0) &amp;&amp; (it &lt; no_of_times_travers));

        return this.valid_string(fn) &amp;&amp; isNaN(fn) ? fn : "";
    },
    get_fn_left: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l - 10 - temp,
            elem_offset.t + e.offsetHeight / 2,
            -10, 0, no_of_times_travers,
            this.get_info(e), e, "left");
        if (!DgoUtils.is_valid_str(fn) &amp;&amp; (e.tagName === "TEXTAREA")) {
            fn = this.get_fn_left_top_corner(e, 10);
        }
        return isNaN(fn) ? fn : "";
    },
    get_fn_left_top_corner: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l - 10 - temp, elem_offset.t + 5,
            -10, 0, no_of_times_travers, this.get_info(e), e, "left");
        return isNaN(fn) ? fn : "";
    },
    get_fn_right: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        //var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l + parseInt(e.offsetWidth) + 10,
                                     elem_offset.t + parseInt(e.offsetHeight) / 2,
                                     10, 0, no_of_times_travers,
                                     this.get_info(e), e, "right");   //10
        return isNaN(fn) ? fn : "";
    },
    get_fn_top: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        // var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l,
            elem_offset.t - 10,
            0, -10, no_of_times_travers,
            this.get_info(e), e, "top");
        return isNaN(fn) ? fn : "";
    },
    get_elem_index: function (e) {
        var parent = e.parentNode;
        if (e === null || parent === null) return -1;

        for (var i = 0; i &lt; parent.children.length; i++) {
            if (parent.children.item(i) === e) return i;
        }
        return -1;
    },
    get_distant_child: function (root, r3, r2, r1) {
        if (root === null || r3 &lt; 0 || r2 &lt; 0 || r1 &lt; 0) return null;

        if (root.children.length &lt;= r3) return null;

        var e = root.children.item(r3);
        if (e.children.length &lt;= r2) return null;

        e = e.children.item(r2);
        if (e.children.length &lt;= r1) return null;

        return e.children.item(r1);
    },
    get_control_fn_from_point_traverse: function (e) {
        var fn = "";
        if ("radio" === e.type || "checkbox" === e.type) {
            if (!(fn = this.get_fn_right(e, 15))) {
                fn = this.get_fn_left(e, 5);
                return fn;
            }
        } else {
            if (fn = this.get_fn_left(e, 12)) return fn;
            if (fn = this.get_fn_top(e, 5)) return fn;
            if (fn = this.get_fn_left(e, 20, 12)) return fn;
        }
        return "";
    },
    get_control_fieldname: function (e) {
        if (!this.check_element(e)) return "";
        var field_name = "";
        try {
            var type = e.type;
            switch (e.tagName) {
                case "INPUT":
                    if ("radio" === type || "checkbox" === type) {
                        field_name = this.get_INPUTradio_or_INPUTcheckbox_fieldname(e);
                    } else if ("text" === type || "textarea" === type || "password" === type || "file" === type) {
                        field_name = this.get_INPUTtext_or_INPUTpassword_fieldname(e);
                    }
                    break;
                case "SELECT":
                    field_name = this.get_SELECT_fieldname(e);
                    break;
                case "TEXTAREA":
                    field_name = this.get_INPUTtext_or_INPUTpassword_fieldname(e);
                    break;
            }
            if (null === field_name || " " === field_name || "" === field_name) field_name = this.get_control_parent_caption(e);
            if (!this.is_valid_fieldname(field_name)) field_name = "";
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof field_name !== "undefined" ? field_name : "";
    },
    get_INPUTradio_or_INPUTcheckbox_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_sibling_inner_text(e))) ||
                ("" !== (res_text = this.get_fn_right(e, 15))) ||
                ("" !== (res_text = this.get_fn_left(e, 5))) ||
                ("" !== (res_text = this.get_text_from_child(e)))) { }
            if ("" === res_text &amp;&amp; e.nextSibling) {
                res_text = e.nextSibling.data ? e.nextSibling.data : e.nextSibling.nodeValue;
            }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return (typeof res_text !== "undefined" &amp;&amp; res_text !== null) ? res_text : "";
    },
    get_INPUTtext_or_INPUTpassword_fieldname: function (e) {
        var res_text = "";
        //var sibling = "";
        try {
            if (("" !== (res_text = this.get_text_from_child(e))) ||
                ("" !== (res_text = this.get_control_fn_from_point_traverse(e)))) { }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_SELECT_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_sibling_inner_text(e))) ||
                ("" !== (res_text = this.get_text_from_child(e))) ||
                ("" !== (res_text = this.get_control_fn_from_point_traverse(e))) ||
                ("" !== (res_text = this.get_fn_right(e)))) { }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_checkbox_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_fn_right(e, 15))) ||
                ("" !== (res_text = this.get_fn_left(e, 5)))) { }
        } catch (err) { exception_debugging(err); }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_combo_button_fieldname: function (e) {
        var res_text = "";
        try {
            var doc = this.get_doc_from_elem(e);
            if (!doc) return res_text;

            var elem_offset = this.get_elem_offset(e);
            var left_ctl_x = elem_offset.l - 10;
            var left_ctl_y = elem_offset.t + e.offsetHeight / 2;
            var left_ctl = doc.elementFromPoint(left_ctl_x, left_ctl_y);
            if (left_ctl) res_text = this.get_SELECT_fieldname(left_ctl);
            if (left_ctl &amp;&amp; !this.is_valid_fieldname(res_text)) {
                res_text = EepUtils.Eep_getFirstTextNodeValue_(left_ctl, 50, false);
            }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    check_element: function (e) {
        try {
            return this.get_doc_from_elem(e);
        } catch (err) { exception_debugging(err); }
        return false;
    },
    check_id: function (e) {
        try {
            if (typeof e.id === "undefined" || e.id === "" || e.id === " ") return false;
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    check_name: function (e) {
        try {
            if (typeof e.name === "undefined" || e.name === "" || e.name === " ") return false;
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    get_sibling_inner_text: function (e) {
        try {
            var sibling = e.nextSibling;
            var id = e.id;
            if (sibling !== null &amp;&amp; this.check_id(e)) {
                var sibling_tag = sibling.tagName;
                var sibling_id = sibling.htmlFor;
                if (typeof sibling_tag === "undefined" || typeof sibling_id === "undefined") return "";
                if ("LABEL" === sibling_tag &amp;&amp; id === sibling_id) return sibling.innerText;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_text_from_child: function (e) {
        try {
            var parent = e.parentNode;
            if (!parent) return "";

            var label_coll = parent.getElementsByTagName("LABEL");
            var count = label_coll.length;
            if (0 === count) {
                if (!parent.parentNode) return "";

                label_coll = parent.parentNode.getElementsByTagName("LABEL");
                count = label_coll.length;
                if (0 === count) return "";
            }
            for (var i = 0; i &lt; count; i++) {
                var child_elem = label_coll[i];
                var child_id = child_elem.htmlFor;

                if ((this.is_valid_fieldname(child_id) &amp;&amp; this.is_valid_fieldname(e.id) &amp;&amp; (child_id === e.id)) ||
                    (this.is_valid_fieldname(child_id) &amp;&amp; this.is_valid_fieldname(e.name) &amp;&amp; (child_id === e.name))) {
                    return child_elem.innerText;
                }
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_control_parent_caption: function (e) {
        var elem = e;
        var it = 0;
        var r_elem = elem.getBoundingClientRect();
        try {
            do {
                var parent = elem.parentNode;
                if (!parent) return "";

                var label_coll = parent.getElementsByTagName("LABEL");
                if (!label_coll) return "";

                var label_child = label_coll.length;
                if (1 === label_child) {
                    var r_label = label_coll[0].getBoundingClientRect();
                    return parseInt(r_elem.bottom) &gt; parseInt(r_label.top) ? label_coll[0].innerText : "";
                } else if (label_child &gt; 1) {
                    break;
                }
                elem = parent;
                it++;
            } while (it &lt; 3);
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_netwvr_radio_fn: function (e) {
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";
        var fn = "";
        var iterations = 5;
        try {
            var elem_offset = this.get_elem_offset(e);
            var start_x = elem_offset.l + e.offsetWidth + 10;
            var start_y = elem_offset.t + e.offsetHeight / 2;
            var fn_e = null;
            do {
                fn_e = doc.elementFromPoint(start_x, start_y);
                fn = this.get_info(fn_e).text;
                start_x += 10;
                start_y += 0;
                iterations--;
            } while (fn_e !== null &amp;&amp; this.valid_string(fn) &amp;&amp; start_x &gt; 0 &amp;&amp; start_y &gt; 0 &amp;&amp; iterations);

            if (!this.valid_string(fn) || !isNaN(fn)) fn = null;
        } catch (err) { exception_debugging(err); }
        return fn;
    },
    is_valid_fieldname: function (field_name) {
        return field_name &amp;&amp; isNaN(field_name) &amp;&amp;
            //[":", " ", "*", ""].indexOf(field_name) === -1 &amp;&amp;
            !DgoUtils.is_in_array(field_name, [":", " ", "*", ""]) &amp;&amp;
            field_name.search("&gt;") === -1 &amp;&amp; field_name.search("&lt;") === -1;
    },
    check_accessKey: function (e) {
        try {
            var inner_txt = e.innerText;
            var p_e;
            if (inner_txt.length === 1) {
                p_e = e.parentNode;
                if (!this.check_element(p_e)) return e;
                var accessKy = p_e.accessKey;
                if (typeof accessKy === "undefined") return e;
                if (inner_txt === accessKy) return p_e;
            }
        } catch (err) { exception_debugging(err); }
        return e;
    },
    is_valid_control_tagname: function (e) {
        try {
            //return ["INPUT", "TEXTAREA", "SELECT", "A"].indexOf(e.tagName) &gt;= 0;
            var valid = DgoUtils.is_in_array(e.tagName, ["INPUT", "TEXTAREA", "SELECT", "A"]);
            if (valid) {
                return true;
            } else if (typeof e.getAttribute("role") != "undefined") {
                valid = DgoUtils.is_in_array(e.getAttribute("role"), ["textbox", "text"]);
            }
            return valid;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    is_valid_fn_element: function (e, flag) {
        try {
            if (flag === "left" &amp;&amp; (e.getElementsByTagName("INPUT").length ||
                e.getElementsByTagName("SELECT").length ||
                e.getElementsByTagName("IMG").length ||
                e.getElementsByTagName("TEXTAREA").length)) {
                return false;
            }
            if (flag === "top" &amp;&amp; (e.getElementsByTagName("TABLE").length ||
                e.getElementsByTagName("IMG").length ||
                e.getElementsByTagName("A").length)) {
                return false;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_ie_zoom_level: function () {
        try {
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version === 7) {
                var rect = document.body.getBoundingClientRect();
                dgo_zoomlevel = Math.ceil((parseInt(rect.right) - parseInt(rect.left)) / document.body.clientWidth * 100);
            } else if (dgo_ie_version &gt;= 8) {
                dgo_zoomlevel = Math.ceil(window.screen.deviceXDPI / window.screen.logicalXDPI * 100);
            }
        } catch (err) {
            exception_debugging(err);
            dgo_zoomlevel = 100;
        }
    },
    page_attr_url: function () {
        return document.URL;
    },
    offset_rect: function (source_rect, left, top) {
        var r = {};
        r.left = parseInt(source_rect.left) + parseInt(left);
        r.top = parseInt(source_rect.top) + parseInt(top);
        r.right = parseInt(source_rect.right) + parseInt(left);
        r.bottom = parseInt(source_rect.bottom) + parseInt(top);
        return r;
    },
    convert_from_string_to_map: function (string, delimiter) {
        try {
            if(string !== null){
                var params = string.split(delimiter);
            }           
            var map = {};
            for (var i = 0; i &lt; params.length; i++) {
                var parts = params[i].split(":");
                map[parts[0]] = parts[1].substr(1, parts[1].length - 2);
            }
            return map;
        } catch (err) {
            exception_debugging(err);
            throw err;
        }
    },
    extract_info_from_string: function (str, startToken, middleToken, endToken) {
        try {
            var start_pos = str.search(startToken);
            if (-1 === start_pos) return "";

            start_pos = str.indexOf(middleToken, start_pos);
            var end_pos = str.indexOf(endToken, start_pos);
            var res = str.substring(start_pos + 2, end_pos - 1);
            return isNaN(res) ? res : Number(res);
        } catch (err) {
            exception_debugging(err);
            throw err;
        }
    },
    set_state: function (element, state) {
        try {
            if (typeof element.disabled !== "undefined") {
                element.disabled = state;
                return 1;   // true
            }
        } catch (err) {
            exception_debugging(err);
            return -1;       // "exception";
        }
        return 0;           // false
    },
    get_state: function (e) {
        var state = "unchecked";
        if (e !== null &amp;&amp; e.tagName === "INPUT" &amp;&amp; (e.type === "radio" || e.type === "checkbox")) {
            if (e.checked) state = "checked";
            return state;
        }
        var role = DgoUtils.get_role(e);
        if (role === "checkbox" || role === "radio") {
            if (e.getAttribute("aria-checked") === "true") state = "checked";
            return state;
        }

        var p_e = e.parentNode;
        if (p_e &amp;&amp; p_e.tagName === "SPAN" &amp;&amp; p_e.role === "checkbox") {
            if (p_e.getAttribute("aria-checked") === "true") state = "checked";
        }
        return state;
    },
    get_properties: function (elem) {
        var name = "";
        var value = "";

        if (elem) {
            value = this.get_value(elem);
            name = this.standard_fieldname(elem);
            if (!DgoUtils.is_valid_str(name)) this.inner_text(elem);
            if (!DgoUtils.is_valid_str(name)) this.button_name(elem);
        }
        return { name: name, value: value };
    },
    string_to_map_of_map: function (string, outer_dlm, inner_dlm) {
        var map = [];
        try {
            if(string !== null){
                var params = string.split(outer_dlm);
            }
            for (var i = 0; i &lt; params.length; i++) {
                var parts = params[i].split(inner_dlm);
                map[i] = [];
                for (var j = 0; j &lt; parts.length; j++) {
                    map[i].push(parts[j]);
                }
            }
        } catch (err) { exception_debugging(err); }
        return map;
    },
    is_obj_hidden: function (obj) {     // IsObjectHidden
        var doc = this.get_doc_from_elem(obj);
        if (!doc) return true;

        var hidden = false;
        if (typeof obj === "object") {
            var frame_rect = doc.body.getBoundingClientRect();
            var obj_rect = obj.getBoundingClientRect();
            if ((parseInt(obj_rect.right) &lt;= parseInt(obj_rect.left)) || (parseInt(obj_rect.bottom) &lt;= parseInt(obj_rect.top))) {
                hidden = true;
            }
            if ((parseInt(obj_rect.bottom) &lt; parseInt(frame_rect.top)) || (parseInt(obj_rect.right) &lt; parseInt(frame_rect.left)) ||
                ((parseInt(obj_rect.top) &gt; parseInt(window.innerHeight)) &amp;&amp; (parseInt(obj_rect.top) &gt; parseInt(frame_rect.bottom))) || (((parseInt(obj_rect.left) &gt; parseInt(window.innerWidth))) &amp;&amp; (parseInt(obj_rect.left) &gt; parseInt(frame_rect.right)))) {
                hidden = true;
            }
        }
        return hidden;
    },
    is_scrollable_element: function (element) {
        if (element === null) return false;
        // Need to add combo also (only multi select)
        switch (element.tagName) {
            case "BODY":
            case "HTML":
            case "DIV":
            case "TEXTAREA":
            case "SECTION":
                return true;
            case "SPAN":
                if (element.className &amp;&amp; -1 !== element.className.search("scroll")) {
                    return true;
                }
                break;
            case "SELECT":
                return element.type === "select-multiple";
            default:
                return false;
        }
    },
    has_scroll: function (element) {
        if (this.is_scrollable_element(element)) {
            var client_h = element.clientHeight;
            var client_w = element.clientWidth;
            if (client_w &lt; 10 &amp;&amp; client_h &lt; 10) return false;
            if (((element.scrollWidth - client_w) &gt; 15) || ((element.scrollHeight - client_h) &gt; 15)) {
                return true;
            }
        }
        return false;
    },
    standard_fieldname: function (e) {
        var fn = "";
        if (fn = this.get_control_fieldname(e)) return fn;
        if (this.is_valid_control_tagname(e)) return "";
        var p = e ? e.parentNode : null;
        var pp = p ? p.parentNode : null;
        var ppp = pp ? pp.parentNode : null;
        if (ppp === null) return "";

        var s_item = this.get_info(e);
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;

        var root = ppp;
        var r3 = this.get_elem_index(pp);
        var r2 = this.get_elem_index(p);
        var r1 = this.get_elem_index(e);

        if (r3 === -1 || r2 === -1 || r1 === -1) return fn;


        var f_e = this.get_distant_child(root, r3 + 2, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 - 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 2, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 2, r2 - 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 3, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 + 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 + 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2 - 1, r1 - 1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 - 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1 - 2);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1 - 1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }
        return "";
    },
    valid_string: function (str) {
        return str &amp;&amp;
            //["", "undefined", " ", "  ", "   ", "    "].indexOf(str) === -1 &amp;&amp;
            !DgoUtils.is_in_array(str, ["", "undefined", " ", "  ", "   ", "    "]) &amp;&amp;
            str.length &lt;= 80;
    },
    inner_text: function (e) {
        try {
            if (e) {
                if (e.children &amp;&amp; e.children.length == 0) {
                    if (e.tagName === "B" &amp;&amp; e.parentNode) {
                        var inner = e.parentNode.innerText;
                        if (typeof inner !== "undefined") return inner;
                    }
                    if (typeof e.innerText !== "undefined") {
                        return "" + e.innerText;
                    }
                } else {
                    var e = EepUtils.Eep_getFirstElementNode_(e);
                    if (e) {
                        if (DgoUtils.is_valid_str(e.innerText)) {
                            return e.innerText;
                        }
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    button_name: function (e) {
        var name = "";
        try {
            if (e) {
                if (e.title &amp;&amp; e.title.length &gt; 0) {
                    name = e.title;
                } else if (e.alt &amp;&amp; e.alt.length &gt; 0) {
                    name = e.alt;
                }
            }
        } catch (err) { exception_debugging(err); }

        return typeof name !== "undefined" ? name : "";
    },
    fieldname_finder: function (e) {
        var fieldname = dgo_button_name(e);
        if (!fieldname) {
            fieldname = dgo_inner_text(e);
        }
        return fieldname;
    },
    RADIO_fieldname: function (e, type) {
        var fn = "";
        if (fn = this.get_control_fieldname(e)) return fn;
        var parent = e.parentNode;
        if (type === "INPUTradio") {
            if (e.nextSibling !== null) {
                if (e.nextSibling.nextSibling !== null) {
                    fn = e.nextSibling.nextSibling.innerText;
                } else {
                    fn = parent.innerText;
                }
            } else {
                fn = parent.innerText;
            }
        } else {
            fn = parent.innerText;
        }
        if (!this.valid_string(fn)) {
            if (parent.previousSibling !== null) fn = parent.previousSibling.innerText;
        }
        if (!this.valid_string(fn)) {
            if (parent.nextSibling !== null) fn = parent.nextSibling.innerText;
        }
        if (!this.valid_string(fn)) {
            var p_next_sib = parent.nextSibling;
            if (p_next_sib !== null &amp;&amp; p_next_sib.nextSibling !== null) {
                fn = p_next_sib.nextSibling.innerText;
            }
        }
        if (!this.valid_string(fn)) {
            var p_parent = parent.parentNode;
            if (p_parent !== null &amp;&amp; p_parent.parentNode !== null) {
                var ppp_prev_sib = p_parent.parentNode.previousSibling;
                if (ppp_prev_sib !== null &amp;&amp; ppp_prev_sib.children.length &gt; 0) {
                    fn = ppp_prev_sib.children.item(0).innerText;
                    if (fn.charAt(fn.length - 1) === ":") {
                        fn = fn.substr(0, fn.length - 1);
                    }
                }
            }
        }

        return fn !== "undefined" &amp;&amp; fn.length &lt;= 80 ? fn : "";
    },
    font_weight: function (e) {
        return (e &amp;&amp; e.currentStyle &amp;&amp; e.currentStyle.fontWeight &gt;= 600) ? 1 : 0;
    },
    font_size: function (e) {
        try {
            if (!this.check_element(e)) return -1;
            var fn_size = "";
            if (e.currentStyle &amp;&amp; e.currentStyle.fontSize) fn_size = this.get_font_size(e.currentStyle.fontSize, false);
            if ((-1 === fn_size) &amp;&amp; e.runtimeStyle &amp;&amp; e.runtimeStyle.fontSize) fn_size = this.get_font_size(e.runtimeStyle.fontSize, false);
            return fn_size;
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    // units:
    // -pt: points  the points used by CSS are equal to 1/72nd of 1in.
    // -pc: picas  1pc is equal to 12pt.
    // -px: pixel units  1px is equal to 0.75pt.
    get_absolute_font_size: function (size) {
        try {
            if (size.indexOf("pt") !== -1) {
                return parseInt(size);
            } else if (size.indexOf("px") !== -1) {
                return Math.round(parseInt(size) * 0.75);
            }
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    get_relative_font_size: function (size) {
        try {
            if (size.indexOf("em") !== -1) {
                return parseFloat(size);
            } else if (size.indexOf("%") !== -1) {
                return parseFloat(size) / 100;
            }
        } catch (err) { exception_debugging(err); }
        return 1;
    },
    get_font_size: function (size, body_elm) {
        if (size.length &lt;= 0) return -1;
        try {
            var abs_font = this.get_absolute_font_size(size);
            if (abs_font !== -1) {
                return abs_font;
            } else {
                var rel_font = this.get_relative_font_size(size);
                var base_font = 0;
                var cur_style = window.document.documentElement.currentStyle;
                if (body_elm) {
                    if (cur_style &amp;&amp; cur_style.fontSize) base_font = parseInt(cur_style.fontSize);
                } else {
                    base_font = this.get_font_size(cur_style.fontSize, true);
                }
                return Math.round(base_font * rel_font);
            }
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    font_family: function (e) {
        if (e &amp;&amp; e.currentStyle) {
            return "" + e.currentStyle.fontFamily;
        } else if (e &amp;&amp; e.runtimeStyle) {
            return "" + e.runtimeStyle.fontFamily;
        } else {
            return "";
        }
    },
    font_color: function (e) {
        if (e &amp;&amp; e.currentStyle) {
            var font_color = e.currentStyle.color;
            return -1 === font_color.search(/rgb/i) ? "" + e.currentStyle.color : DgoUtils.rgb_to_hex(font_color);
        }
        return "";
    },
    bg_color: function (e) {
        return e &amp;&amp; e.currentStyle &amp;&amp; e.currentStyle.backgroundColor !== "" ?
            "#" + e.currentStyle.backgroundColor :
            "#ffffff";
    },
    get_value: function (e) {
        var res = "";
        if (e) {
            if (e.tagName === "SELECT" &amp;&amp; e.options) {
                for (var i = 0; i &lt; e.options.length; i++) {
                    if (e.options[i].selected) res += "{*}";
                    res = res + e.options[i].text + "\n";
                }
            } else if (e.tagName === "INPUT" &amp;&amp; e.value) {
                res = e.value;
            } else if (e.tagName === "TEXTAREA" &amp;&amp; e.value) {
                res = e.value;
            } else if (e.tagName === "BODY" &amp;&amp; typeof e.contentEditable !== "undefined" &amp;&amp; e.contentEditable === "true") {
                res = e.innerText;
            }
        }
        return res;
    },
    set_value: function (e, val) {
        var res = "&lt;error&gt;";
        if (e) {
            if (e.tagName === "SELECT" &amp;&amp; e.options) {
                for (var i = 0; i &lt; e.options.length; i++) {
                    if (e.options[i].text === val) {
                        e.options[i].selected = true;
                        e.onchange();
                        res = "ok";
                        break;
                    }
                }
            } else if (e.tagName === "INPUT") {
                if (e.type === "radio" || e.type === "checkbox") {
                    if (val === "checked") {
                        e.checked = true;
                    } else if (val === "unchecked") {
                        e.checked = false;
                    }
                } else {
                    e.value = val;
                }
                res = "ok";
            }
        }
        return res;
    },
    inner_html_text: function (e) {
        var res = "";
        var innertext = e.innerText.toLowerCase();
        var innerhtml = e.innerHTML.toLowerCase();
        if (innertext) {
            var result = innerhtml.indexOf(innertext);
            if (result &gt; -1) {
                res = e.innerHTML.substring(result, result + innertext.length)
            } else {
                res = e.innerText;
            }
        } else {
            res = e.innerHTML;
        }
        return res.trim();
    }
};
// =====================================================================================
// =====================================================================================

// ====================================== String prototype extensions ====================================== //
var String_ltrimRE_ = /^[ \r\n\t\xA0]*(.*$)/m;
var String_rtrimRE_ = /[ \r\n\t\xA0]*$/m;

String.prototype.ltrim = function () {
    return String_ltrimRE_.exec(this)[1];
};
String.prototype.rtrim = function () {
    var match = String_rtrimRE_.exec(this);
    return this.substr(0, this.length - match[0].length);
};
String.prototype.alltrim = function () {
    var ret_val = this.ltrim();
    return ret_val.rtrim();
};
String.prototype.fast_trim = function () {
    return this.replace(/^ */, "").replace(/ *$/, "");
};
String.prototype.asJSstring = function () {
    var ret_val = new String(this);
    ret_val = ret_val.replace(/[\\]/g, "\\\\");
    ret_val = ret_val.replace(/[""]/g, "");
    ret_val = ret_val.replace(/[\n]/g, "\\n");
    ret_val = ret_val.replace(/[\r]/g, "\\r");
    ret_val = ret_val.replace(/[\t]/g, "\\t");
    ret_val = ret_val.replace("'", "");
    ret_val = ret_val.replace(":", "");
    return "\"" + ret_val + "\"";
};

if (!String.prototype.trim) {
    (function () {
        // Make sure we trim BOM and NBSP
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        String.prototype.trim = function () {
            return this.replace(rtrim, '');
        };
    })();
}
// =============================================== RECOGNITION ===============================================
var delimiter = "|##|";
var elem_with_frame_path = "window";

DGO.BaseHTMLElementRecognition = function () { };

DGO.BaseHTMLElementRecognition.prototype = {
    element_path: "",
    element_index_path: "",
    element_rect: null,
    bc_rect: null,
    element: null,
    eep: "",
    object_type: "",
    object_sub_type: "",
    element_rect_str: "",
    client_x: null,
    client_y: null,
    frame_offset_x: 0,
    frame_offset_y: 0,
    frame_path: "",
    gen_path: 1,
    has_role: false,

    get_cnlt_props: function () {
        try {
            var prop = "fieldname" + "=" + DgoProfile.standard_fieldname(this.element) + "|+|";
            prop += "fieldvalue" + "=" + DgoProfile.get_value(this.element) + "|+|";
            prop += "size" + "=" + DgoProfile.font_size(this.element) + "|+|";
            prop += "fontfamily" + "=" + DgoProfile.font_family(this.element) + "|+|";
            prop += "color" + "=" + DgoProfile.font_color(this.element) + "|+|";
            prop += "bgcolor" + "=" + DgoProfile.bg_color(this.element) + "|+|";
            prop += "innertext" + "=" + DgoProfile.inner_text(this.element);
            return prop;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    check_input: function () {
        return window !== null &amp;&amp; window.document !== null;
    },
    init: function (point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
        this.gen_path = gen_path;
        this.element_rect = {};
        this.bc_rect = {};
        this.client_x = point_x;
        this.client_y = point_y;
        DgoProfile.get_ie_zoom_level();
        this.frame_path = frame_path;
        elem_with_frame_path = "window";
        this.frame_offset_x = top_frame_left;
        this.frame_offset_y = top_frame_top;
    },
    get_element_from_point: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;

            this.element = DgoProfile.check_accessKey(this.element);
            if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentNode;
            var trv_elem = this.element;
            for (var iter = 0; iter &lt; 5; iter++) {
                if (trv_elem.tagName === "BUTTON") {
                    this.element = trv_elem;
                    break;
                }
                trv_elem = trv_elem.parentNode;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    exec_on_main_win: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = this.get_top_window().document.elementFromPoint(client_x, client_y))) return false;
            this.frame_path = "";
            this.element = DgoProfile.check_accessKey(this.element);
            if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentNode;
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_element_path: function () {
        try {
            var tagname = this.element.tagName;
            var tag_coll = window.document.getElementsByTagName(tagname);
            if (!tag_coll) return tag_coll;

            var tag_coll_length = tag_coll.length;
            for (var i = 0; i &lt; tag_coll_length; i++) {
                var child = tag_coll.item(i);
                if (this.element === child) {
                    //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[" + i + "]";  // document.all deprecated in IE11
                    this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[" + i + "]";
                    return true;
                }
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_bc_rect: function () {
        try {
            this.element_rect = this.element.getBoundingClientRect();
            var node = this.element;
            if (node &amp;&amp; node.parentNode) {
                var p_node = node.parentNode;
                var p_elem = p_node;
                if (p_elem &amp;&amp; "clipper" === p_elem.tagName) {
                    if (p_node.parentNode) p_node = p_node.parentNode;
                    this.element_rect = p_node.getBoundingClientRect();
                }
                if (p_elem &amp;&amp; "SPAN" === p_elem.tagName &amp;&amp; "th-bt-span" === p_elem.className) {
                    if (p_node.parentNode) {
                        p_node = p_node.parentNode;
                        if (p_node &amp;&amp; "A" === p_node.tagName &amp;&amp; p_node.className &amp;&amp;
                            -1 !== p_node.className.search("th-bt th-bt")) {
                            this.element_rect = p_node.getBoundingClientRect();
                        }
                    }
                }
            }
            if ((parseInt(this.element_rect.right) - parseInt(this.element_rect.left)) &lt; 3) {
                var r = {};
                r.right = parseInt(this.element_rect.right) + 5;
                r.left = parseInt(this.element_rect.left) - 5;
                r.top = parseInt(this.element_rect.top);
                r.bottom = parseInt(this.element_rect.bottom);
                this.element_rect = r;
                this.element_rect.right = parseInt(this.element_rect.right) + parseInt(5);
                this.element_rect.left = parseInt(this.element_rect.left) - parseInt(5);
                if (this.element_rect.left &lt; 0) {
                    this.element_rect.left = 0;
                }
            }
            if ((parseInt(this.element_rect.bottom) - parseInt(this.element_rect.top)) &lt; 3) {
                var rt = {};
                rt.bottom = parseInt(this.element_rect.bottom) + 5;
                rt.top = parseInt(this.element_rect.top) - 5;
                rt.left = parseInt(this.element_rect.left);
                rt.right = parseInt(this.element_rect.right);
                this.element_rect = rt;
                if (this.element_rect.top &lt; 0) {
                    this.element_rect.top = 0;
                }
            }
            this.element_rect = DgoProfile.offset_rect(this.element_rect, this.frame_offset_x, this.frame_offset_y);
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_top_window: function () {
        try {
            if (window.top.innerWidth) {
                return window.top;
            }
        } catch (err) { exception_debugging(err); }
        return window;
    },
    execute_self_handler: function (clickptx, clickpty, elem) {
        //these points are wrt client co-ordinate i.e. after offsetting loff_
        //Call dgo_self_handler and update type and rect if applicable
        var ret_val = "nonscrollable";
        if (DgoProfile.is_scrollable_element(elem)) {
            var client_h = elem.clientHeight;
            var client_w = elem.clientWidth;
            if (client_w &lt; 10 &amp;&amp; client_h &lt; 10) return ret_val;
            ret_val = "scrollable";
            var b_rect = elem.getBoundingClientRect();
            b_rect = DgoProfile.offset_rect(b_rect, this.frame_offset_x, this.frame_offset_y);
            clickptx = clickptx + this.frame_offset_x;
            clickpty = clickpty + this.frame_offset_y;
            var scroll_button_size = 30;
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version &lt; 10) scroll_button_size = 16;
            //var client_l = elem.clientLeft;
            //var client_t = elem.clientTop;
            var scroll_w = elem.scrollWidth;
            var scroll_h = elem.scrollHeight;
            var scroll_l = elem.scrollLeft;
            var scroll_t = elem.scrollTop;
            var fac;
            if (scroll_w &gt; client_w) {
                var hb_rect = {};

                hb_rect.left = b_rect.left;
                hb_rect.top = b_rect.top + client_h;
                hb_rect.right = hb_rect.left + client_w;
                hb_rect.bottom = b_rect.bottom;
                if (hb_rect.left &lt; 0) hb_rect.left = 0;

                if (hb_rect.top == hb_rect.bottom) {
                    hb_rect.right = window.innerWidth;
                    if (hb_rect.right &lt; 0) hb_rect.right = 0;
                    hb_rect.bottom = window.innerHeight;
                }
                if (0 &gt; hb_rect.top) {
                    var top_diff = this.get_top_window().innerHeight - window.innerHeight;
                    hb_rect.top = top_diff;
                }
                // if click point falls in scroll area, do the processing otherwise return it
                if (clickpty &gt; hb_rect.top &amp;&amp; clickpty &lt; hb_rect.bottom) {
                    fac = 0.0;
                    if (clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + scroll_button_size)) {
                        this.object_sub_type = "HScrollBtnL";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + scroll_button_size) + "," + hb_rect.bottom;
                    }
                    if (clickptx &gt; (hb_rect.right - scroll_button_size) &amp;&amp; clickptx &lt; hb_rect.right) {
                        this.object_sub_type = "HScrollBtnR";
                        return (hb_rect.right - scroll_button_size) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                    }
                    hb_rect.left += scroll_button_size;
                    hb_rect.right -= scroll_button_size;
                    if (scroll_h &gt; 0) fac = (client_w - scroll_button_size) / scroll_w;
                    else fac = 1;
                    var hb_wdth = Math.round(fac * (client_w - scroll_button_size));
                    if (scroll_l &gt; 0 &amp;&amp; clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + Math.ceil(scroll_l * fac))) {
                        this.object_sub_type = "HScrollAreaL";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + Math.round(scroll_l * fac)) + "," + hb_rect.bottom;
                    }
                    hb_rect.left += Math.round(scroll_l * fac);
                    if (hb_rect.right &gt; (hb_rect.left + hb_wdth) &amp;&amp; clickptx &gt; (hb_rect.left + hb_wdth) &amp;&amp; clickptx &lt; hb_rect.right) {
                        this.object_sub_type = "HScrollAreaR";
                        return (hb_rect.left + hb_wdth) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;

                    } else if (clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + hb_wdth)) {
                        this.object_sub_type = "HScrollBar";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + hb_wdth) + "," + hb_rect.bottom;
                    }
                }
            }
            if (scroll_h &gt; client_h) {
                var vb_rect = {};
                vb_rect.left = b_rect.left + client_w;
                vb_rect.top = b_rect.top;
                vb_rect.right = b_rect.right;
                vb_rect.bottom = vb_rect.top + client_h;
                if (vb_rect.left == vb_rect.right) {
                    vb_rect.right = this.get_top_window().innerWidth;
                    vb_rect.bottom = this.get_top_window().innerHeight;
                }
                if (0 &gt; vb_rect.top) {
                    var top_diff = this.get_top_window().innerHeight - window.innerHeight;
                    vb_rect.top = top_diff;
                }

                // if click point falls in scroll area, do the processing otherwise return it
                if ((clickptx &gt; vb_rect.left) &amp;&amp; (vb_rect.right &gt; clickptx)) {
                    fac = 0.0;
                    if (clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + scroll_button_size)) {
                        this.object_sub_type = "VScrollBtnT";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + scroll_button_size);
                    }
                    if (clickpty &gt; (vb_rect.bottom - scroll_button_size) &amp;&amp; clickpty &lt; vb_rect.bottom) {
                        this.object_sub_type = "VScrollBtnB";
                        return vb_rect.left + "," + (vb_rect.bottom - scroll_button_size) + "," + vb_rect.right + "," + vb_rect.bottom;
                    }
                    vb_rect.top += scroll_button_size;
                    vb_rect.bottom -= scroll_button_size;
                    if (scroll_h &gt; 0) fac = (client_h - scroll_button_size) / scroll_h;
                    else fac = 1;
                    var vb_hght = Math.round(fac * (client_h - scroll_button_size));
                    if (scroll_t &gt; 0 &amp;&amp; clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + Math.ceil(scroll_t * fac))) {
                        this.object_sub_type = "VScrollAreaT";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + Math.round(scroll_t * fac));
                    }
                    vb_rect.top += Math.round(scroll_t * fac);
                    if (vb_rect.bottom &gt; (vb_rect.top + vb_hght) &amp;&amp; clickpty &gt; (vb_rect.top + vb_hght) &amp;&amp; clickpty &lt; vb_rect.bottom) {
                        this.object_sub_type = "VScrollAreaB";
                        return vb_rect.left + "," + (vb_rect.top + vb_hght) + "," + vb_rect.right + "," + vb_rect.bottom;

                    } else if (clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + vb_hght)) {
                        this.object_sub_type = "VScrollBar";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + vb_hght);
                    }
                }
            }
        }
        return ret_val;
    },
    get_element_eep: function () {
        try {
            var elem_path_webcompat = "";
            if (dgo_webcompat) {
                this.get_element_index_path();
                elem_path_webcompat = this.element_index_path;
            }
            this.eep = "eep_frame=\"" + this.frame_path + "\";eep_simple_path=\"" + elem_path_webcompat +
                "\";" + EepUtils.Eep_generate(this.element) + "client_x=\"" + this.client_x + "\";client_y=\"" + this.client_y + "\";";
            if (this.frame_path === "") this.frame_path = "-1";
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    recognition_output: function () {
        try {
            var obj_rect = this.object_sub_type === "" ?
                parseInt(this.element_rect.left) + "," + parseInt(this.element_rect.top) + "," +
                parseInt(this.element_rect.right) + "," + parseInt(this.element_rect.bottom) :
                this.element_rect_str;
            return ("epath|=|" + this.element_path + delimiter + "type|=|" + this.object_type + delimiter + "rect|=|" + obj_rect + delimiter + "eep|=|" + this.eep);
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_element_index_path: function () {
        try {
            var element_path = [];
            var delimiter = ":";
            this.get_index_path_recursive(this.element, window.document.body, element_path);
            var length = element_path.length;
            for (var i = 0; i &lt; length; i++) {
                if (i === length - 1) delimiter = "";
                this.element_index_path = this.element_index_path + element_path[i] + delimiter;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_index_path_recursive: function (element, root, path) {
        try {
            if (root === null) return false;
            if (element === root) return true;
            var collection = root.children;
            if (collection === null) return false;

            var length = collection.length;
            for (var i = 0; i &lt; length; i++) {
                path.push(i);
                var item = collection.item(i);
                if (this.get_index_path_recursive(element, item, path)) return true;
                path.pop(i);
            }
        } catch (err) { exception_debugging(err); }
        return false;
    }
};   // end HTMLElementRecognition.prototype
//===============================================RERECOGNITION===============================================
var rerecognition_frame_offset_x = 0;
var rerecognition_frame_offset_y = 0;

DGO.BaseHTMLElementRerecognition = function () { };

DGO.BaseHTMLElementRerecognition.prototype = {
    recording_element_type: "",
    element_path: "",
    element_index_path: "",
    eep: "",
    element_rect: null,
    element_rect_str: "",
    element: null,
    object_type: "",
    object_sub_type: "",
    client_x: null,
    client_y: null,
    check_names: "",
    recording_element_info_map: null,

    check_input: function (eepInput) {
        return window &amp;&amp; eepInput &amp;&amp; eepInput !== "" &amp;&amp; window.document;
    },
    init: function (eepInput, obj_type, check_names) {
        try {
            this.element_index_path = "";
            this.element_rect_str = "";
            this.object_type = "";
            this.object_sub_type = "";
            this.element = null;
            this.recording_element_type = obj_type;
            elem_index_within_frame = -1;
            this.element_path = DgoProfile.extract_info_from_string(eepInput, "element_path", "=", ";");
            this.client_x = DgoProfile.extract_info_from_string(eepInput, "client_x", "=", ";");
            this.client_y = DgoProfile.extract_info_from_string(eepInput, "client_y", "=", ";");
            var start_pos = eepInput.search("element_path");

            if (-1 === start_pos) this.eep = eepInput;
            else this.eep = eepInput.substring(0, start_pos);

            this.element_rect = {};
            this.check_names = check_names;
            this.recording_element_info_map = {};
            elem_with_frame_path = "window";
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_elem_from_index_path: function () {
        try {
            //this.element = Eep_resolve(this.eep, 0, this.check_names);
            this.element = eval(Eep_resolve3(this.eep, 0, this.check_names));
            if (this.element) {
                this.element_rect_str = this.execute_self_handler(this.recording_element_type, this.element);
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_rect: function () {
        try {
            var br = this.element.getBoundingClientRect();
            this.element_rect.left = ((br.left &gt; 0) ? parseInt(br.left) : 0) + parseInt(rerecognition_frame_offset_x);
            this.element_rect.right = parseInt(br.right) + parseInt(rerecognition_frame_offset_x);
            this.element_rect.top = parseInt(br.top) + parseInt(rerecognition_frame_offset_y);
            this.element_rect.bottom = parseInt(br.bottom) + parseInt(rerecognition_frame_offset_y);
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_element_path: function () {
        try {
            var tagname = this.element.tagName;
            if (-1 === elem_index_within_frame) {
                var tag_coll = null;
                tag_coll = window.document.getElementsByTagName(tagname);
                var tag_coll_length = tag_coll.length;
                for (var i = 0; i &lt; tag_coll_length; i++) {
                    var child = tag_coll.item(i);
                    if (this.element === child) {
                        //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[" + i + "]";  // document.all deprecated in IE11
                        this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[" + i + "]";
                        return true;
                    }
                }
                //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[0]";    // document.all deprecated in IE11
                this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[0]";
            } else {
                //this.element_path = "window.document.all.tags(\"" + tagname + "\")[" + elem_index_within_frame + "]"; // document.all deprecated in IE11
                this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")[" + elem_index_within_frame + "]";
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    rerecognition_output: function () {
        var r = this.element_rect;
        var obj_rect = this.object_sub_type === "" ?
            parseInt(r.left) + "," + parseInt(r.top) + "," + parseInt(r.right) + "," + parseInt(r.bottom) :
            this.element_rect_str;
        return ("type=" + this.object_type + delimiter + "rect=" + obj_rect + delimiter + "epath=" + this.element_path);
    },
    execute_self_handler: function (obj_type, elem) {
        var ret_val = "";
        if (DgoProfile.is_scrollable_element(elem)) {
            var sub_type = this.recording_element_type;
            var client_h = elem.clientHeight;
            var client_w = elem.clientWidth;
            var b_rect = elem.getBoundingClientRect();
            b_rect = DgoProfile.offset_rect(b_rect, rerecognition_frame_offset_x, rerecognition_frame_offset_y);
            var scroll_button_size = 30;
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version &lt; 10) scroll_button_size = 16;

            //var client_l = elem.clientLeft;
            //var client_t = elem.clientTop;
            var scroll_w = elem.scrollWidth;
            var scroll_h = elem.scrollHeight;
            var scroll_l = elem.scrollLeft;
            var scroll_t = elem.scrollTop;
            var fac;

            if (sub_type.indexOf("HScroll") !== -1) {
                this.object_sub_type = sub_type;
                var hb_rect = {};

                hb_rect.left = b_rect.left;
                hb_rect.top = b_rect.top + client_h;
                hb_rect.right = hb_rect.left + client_w;
                hb_rect.bottom = b_rect.bottom;

                fac = 0.0;
                if (sub_type === "HScrollBtnL") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + scroll_button_size) + "," + hb_rect.bottom;
                }
                if (sub_type === "HScrollBtnR") {
                    return (hb_rect.right - scroll_button_size) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                }
                //var temp_rect = b_rect;
                hb_rect.left += scroll_button_size;
                hb_rect.right -= scroll_button_size;
                fac = scroll_h &gt; 0 ? (client_w - scroll_button_size) / scroll_w : 1;

                var hb_wdth = Math.round(fac * (client_w - scroll_button_size));
                if (sub_type === "HScrollAreaL") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + Math.round(scroll_l * fac)) + "," + hb_rect.bottom;
                }
                hb_rect.left += Math.round(scroll_l * fac);
                if (sub_type === "HScrollAreaR") {
                    return (hb_rect.left + hb_wdth) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                }
                if (sub_type === "HScrollBar") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + hb_wdth) + "," + hb_rect.bottom;
                }
            }
            if (sub_type.indexOf("VScroll") !== -1) {
                this.object_sub_type = sub_type;
                var vb_rect = {};
                vb_rect.left = b_rect.left + client_w;
                vb_rect.top = b_rect.top;
                vb_rect.right = b_rect.right;
                vb_rect.bottom = vb_rect.top + client_h;

                if (vb_rect.left == vb_rect.right) {
                    vb_rect.right = this.get_top_window().innerWidth;
                    vb_rect.bottom = this.get_top_window().innerHeight;
                }
                if (0 &gt; vb_rect.top) {
                    var top_diff = this.get_top_window().innerHeight - window.innerHeight;
                    vb_rect.top = top_diff;
                }

                fac = 0.0;
                if (sub_type === "VScrollBtnT") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + scroll_button_size);
                }
                if (sub_type === "VScrollBtnB") {
                    return vb_rect.left + "," + (vb_rect.bottom - scroll_button_size) + "," + vb_rect.right + "," + vb_rect.bottom;
                }
                var temp_rect = b_rect;
                vb_rect.top += scroll_button_size;
                vb_rect.bottom -= scroll_button_size;
                fac = scroll_h &gt; 0 ? (client_h - scroll_button_size) / scroll_h : 1;
                var vb_hght = Math.round(fac * (client_h - scroll_button_size));

                if (sub_type === "VScrollAreaT") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + Math.round(scroll_t * fac));
                }
                vb_rect.top += Math.round(scroll_t * fac);
                if (sub_type === "VScrollAreaB") {
                    return vb_rect.left + "," + (vb_rect.top + vb_hght) + "," + vb_rect.right + "," + vb_rect.bottom;
                }
                if (sub_type === "VScrollBar") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + vb_hght);
                }
            }
        }
        return ret_val;
    }
};   // end HTMLElementRerecognition.prototype
// =============================================== Eep ================================================ //

DGO.BaseEep = function () { };

DGO.BaseEep.prototype = {

    ok: false,
    eep_path: null,
    eep_options: null,
    eep_atts: null,
    eep_coll: null,
    eep_parents: null,
    eep_siblingTags2: null,
    eep_elem_index: null,
    eep_elem_tag: null,
    eep_frame: null,
    eep_frame_name: null,
    eep_frame_src: null,
    client_x: null,
    client_y: null,
    options_: null,
    path_: null,
    coll_: null,
    eep_ori_: null,

    init: function (eep_string, resolve_options) {  // used to be Eep(eepString_, resolveOptions_)
        with (this) {
            this.options_ = resolve_options || {};
            this.eep_ori_ = eep_string;
            try {
                eval(eep_string);
            } catch (err) { exception_debugging(err); }
            this.path_ = this.eep_path;
            this.coll_ = typeof this.eep_coll === "object" &amp;&amp; this.eep_coll ?
                { collection: this.eep_coll.n, index: this.eep_coll.i, subindex: this.eep_coll.ii } :
                { collection: "", index: 0, subindex: -1 };
            this.ok = true;
        }
    },
    eep_resolve: function () {
        var obj = null;
        try {
            if (!this.eep_path || !this.eep_atts.tagName) {
                return window.document.body;
            }
            try {
                obj = EepUtils.Eep_resolveSimple(this.path_, this.eep_options);
                if (true === (this.qaElement_(obj))) return obj;
            } catch (err) { exception_debugging(err); }
            if (this.client_x !== "" &amp;&amp; this.client_y !== "") {
                obj = EepUtils.Eep_resolveClientPt_(this.client_x, this.client_y,
                    this.eep_atts, this.options_);
                if (obj &amp;&amp; (this.eep_atts.tagName === obj.tagName) &amp;&amp; (true === (this.qaElement_(obj)))) {
                    return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_elem_tag) {
                obj = this.Eep_resolveTagIndex_();
                if (obj) return obj;
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_atts.id) {
                obj = EepUtils.Eep_resolveId_(this.eep_atts.id);
                if (obj) {
                    if (true === (this.qaElement_(obj))) return obj;
                    obj = EepUtils.Eep_resolveInputValue_(this.eep_atts.tagName, this.eep_atts.type,
                        this.eep_atts.name, this.eep_atts.value);
                    if (obj) return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
        try {
            obj = EepUtils.Eep_resolveName_(this.eep_atts.name, this.eep_atts.tagName, true /*unique*/);
            if (obj) return obj;
        } catch (err) { exception_debugging(err); }
        try {
            if (this.options_.eep_use_text) {
                obj = EepUtils.Eep_resolveFirstText_(this.eep_atts.tagName, this.eep_atts.firstText,
                    this.options_, this.eep_atts.L || 0);
                if (true === (this.qaElement_(obj))) return obj;
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_atts.id) {
                obj = EepUtils.Eep_resolveId_(this.eep_atts.id);
                if (typeof obj === "object" &amp;&amp; obj) {
                    if (true === (this.qaElement_(obj))) return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
    },
    Eep_resolveTagIndex_: function () {
        try {
            var obj = null;
            var tag_coll = window.document.getElementsByTagName(this.eep_elem_tag);
            var coll_length = tag_coll ? tag_coll.length : 0;
            if (coll_length) {
                var orig_index = Number(this.eep_elem_index);
                if (orig_index &lt; coll_length) {
                    obj = tag_coll.item(orig_index);
                    current_rerecognition_elem_index = orig_index;
                }
                if (obj &amp;&amp; (true === (this.qaElement_(obj)))) {
                    elem_index_within_frame = orig_index;
                    return obj;
                } else {
                    var iter = 1;
                    var keep_checking = true;

                    while (keep_checking) {
                        var trial_index = orig_index - iter;
                        if (trial_index &lt; coll_length &amp;&amp; trial_index &gt;= 0) {
                            obj = tag_coll.item(trial_index);
                            current_rerecognition_elem_index = trial_index;
                            if (true === (this.qaElement_(obj))) {
                                elem_index_within_frame = trial_index;
                                return obj;
                            }
                        }
                        trial_index = orig_index + iter;
                        if (trial_index &lt; coll_length) {
                            obj = tag_coll.item(trial_index);
                            current_rerecognition_elem_index = trial_index;
                            if (true === (this.qaElement_(obj))) {
                                elem_index_within_frame = trial_index;
                                return obj;
                            }
                        } else if (iter &gt; orig_index) {
                            keep_checking = false;
                        }
                        iter++;
                        if (iter &gt; 50) keep_checking = false;
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    qaPath_: function (obj) {
        try {
            if (!obj) return false;
            if (obj.tagName === "BODY" || obj.tagName === "FRAME") return true;

            var i = 0;
            var p = obj.parentNode;
            var parent, atts;
            while (p &amp;&amp; (p.tagName !== "BODY") &amp;&amp; (p.tagName !== "FRAME") &amp;&amp;
                typeof this.eep_parents[i] === "object") {
                parent = this.eep_parents[i];
                atts = parent.eep_atts || parent;
                if (!EepUtils.Eep_qaElement_(p, atts)) return "!=PATH(" + i + ")";

                p = p.parentNode;
                ++i;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    qaElementAndPath_: function (obj) {
        var rc;
        return true !== (rc = this.qaElement_(obj)) ? rc : this.qaPath_(obj);
    },
    qaElement_: function (obj) {
        return EepUtils.Eep_qaElement_(obj, this.eep_atts, this.options_);
    },
    qaInputElement_: function (obj) {
        return EepUtils.Eep_qaInputElement_(obj, this.eep_atts);
    }
};  // end Eep.prototype

DGO.BaseEepUtils = function () { };

DGO.BaseEepUtils.prototype = {
    Eep_attrNames_: ["id", "name", "tagName", "type", "src"],
    Eep_getFirstTextNodeRE_: /[']?[^ \r\n\t][']?/,
    Eep_specialAttributes_: ["data-help-id", "data-tilecatalogid"],

    Eep_resolveClientPt_: function (client_x, client_y, eep_atts, options) {
        try {
            var obj = window.document.elementFromPoint(Number(client_x), Number(client_y));
            if (obj &amp;&amp; obj.tagName === "B") {
                obj = obj.parentNode;
            }
            if (obj &amp;&amp; (eep_atts.tagName === obj.tagName) &amp;&amp; (true === this.Eep_qaElement_(obj, eep_atts, options))) {
                return obj;
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveFirstText_: function (tagname, first_text, options, text_truncation) {
        if (!first_text) return null;

        if (text_truncation &gt; 0 &amp;&amp;
            first_text.length === text_truncation + 1 &amp;&amp;
            first_text.charAt(text_truncation) === "^") {
            first_text = first_text.substr(0, text_truncation);
        }
        var objs_hit = [];
        var objs = window.document.getElementsByTagName(tagname);
        var cmp1 = this.Eep_getRe4FirstText_(first_text, options);
        var i, obj, cmp2;
        if (cmp1) {
            for (i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                cmp2 = this.Eep_getFirstTextNodeValue_(obj, text_truncation);

                if (cmp1 === this.Eep_getRe4FirstText_(cmp2, options)) {
                    objs_hit[objs_hit.length] = obj;
                }
            }
        } else {
            for (i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                cmp2 = this.Eep_getFirstTextNodeValue_(obj, text_truncation);
                if (first_text === cmp2) objs_hit[objs_hit.length] = obj;
            }
        }
        return objs_hit.length === 1 ? objs_hit[0] : null;
    },
    Eep_getFirstTextNodeValue_: function (obj_, text_truncation_, flagDelimiter_) {   // SAP Web 3 version
        var node = this.Eep_getFirstTextNode_(obj_);
        if (!node || typeof node.nodeValue !== "string") return "";
        var ret_val = (new String(node.nodeValue)).alltrim();
        return text_truncation_ &gt; 0 &amp;&amp; ret_val.length &gt; text_truncation_
            ? ret_val.substr(0, text_truncation_) + (flagDelimiter_ ? "^" : "")
            : ret_val;
    },
    Eep_getAttribute_: function (obj_, id) {
        try {

            var attr = obj_.getAttribute(id);
            if (attr) {
                return attr;
            }
        } catch (e) { exception_debugging(e); }
        return "";
    },
    Eep_getElementInnerValue_: function (obj_, text_truncation_, flagDelimiter_) {
        var ret_val = "";
        try {
            var node = this.Eep_getFirstElementNode_(obj_);
            ret_val = node ? node.innerText : obj_.innerText;
            ret_val = ret_val.alltrim();
            return text_truncation_ &gt; 0 &amp;&amp; ret_val.length &gt; text_truncation_ ?
                ret_val.substr(0, text_truncation_) + (flagDelimiter_ ? "^" : "") : ret_val;

        } catch (e) { exception_debugging(e); }
        return "";
    },
    Eep_generateAttsString_: function (obj, options, text_truncation) {
        var str = "";
        var i, att, v, t;

        for (i = 0; i &lt; this.Eep_attrNames_.length; ++i) {
            att = this.Eep_attrNames_[i];
            v = obj[att];
            t = typeof v;
            if (v &amp;&amp; t === "string") {
                if (att === "id") {
                    var el;
                    var all_elems = window.document.getElementsByTagName("*");
                    //if (window.document.all &amp;&amp; (el = window.document.all[v]) &amp;&amp;
                    if (all_elems &amp;&amp; (el = all_elems[v]) &amp;&amp;
                        typeof el.length === "number" &amp;&amp; el.length !== 1) // mySAP, i.e., has lots of duplicate IDs
                    {
                        v = "";
                        t = "string";  // this makes the following ignore the ID
                    }
                }

                if (att === "name") {
                    if (window.document.getElementsByName(v).length !== 1) {
                        v = "";
                        t = "string";  // this makes the following ignore the ID
                    }
                }

                if (att === "src") {
                    v = DgoUtils.extract_img_src(v);
                }
            }

            if (v || (t !== "undefined" &amp;&amp; t !== "unknown" &amp;&amp; t !== "string")) {

                if (str !== "") str += ",";
                if (att === "type" &amp;&amp; v === "radio") str += ("value:" + obj.value.asJSstring() + ",");

                if (t === "number") {
                    str += (att + ":" + v);
                } else {
                    if (att === "tagName" &amp;&amp; v === "FRAME") v = "BODY";
                    str += (att + ':"' + v + '"');
                }
            }
        }
        for (var i in this.Eep_specialAttributes_) {
            var attr = this.Eep_getAttribute_(obj, this.Eep_specialAttributes_[i]);
            if (attr) {
                str += ("," + this.Eep_specialAttributes_[i].asJSstring() + ":" + attr.asJSstring());
            }
        }

        if (obj.tagName &amp;&amp; eep_useInnerText &amp;&amp; eep_useInnerText.indexOf(":" + obj.tagName + ":") &gt;= 0 &amp;&amp; !DgoProfile.has_scroll(obj)) {
            t = this.Eep_getFirstTextNodeValue_(obj, text_truncation, true /*with delimiter*/);
            if (t || (t = this.Eep_getElementInnerValue_(obj, text_truncation, true))) {
                str += (text_truncation &gt; 0 ? ",L:" + text_truncation + ",firstText:" + t.asJSstring() : ",firstText:" + t.asJSstring());
            }
        }
        var objRect = obj.getBoundingClientRect();
        var objHt = parseInt(objRect.bottom) - parseInt(objRect.top);
        var objWt = parseInt(objRect.right) - parseInt(objRect.left);
        str += (",ht:" + objHt + ",wt:" + objWt);
        return str;
    },
    Eep_qaElementText_: function (obj, atts, options) {
        if (obj.tagName &amp;&amp; eep_useInnerText &amp;&amp; eep_useInnerText.indexOf(":" + obj.tagName + ":") &gt;= 0) {
            var newtext = this.Eep_getFirstTextNodeValue_(obj, 50, true /*with delimiter*/);
            if (!newtext) {
                newtext = this.Eep_getElementInnerValue_(obj, 50, true);
            }
        }
        if (atts.firstText) {
            var firstText = atts.firstText;
            var textTruncation = atts.L || 0;
            if (textTruncation &gt; 0 &amp;&amp; firstText.length === textTruncation + 1 &amp;&amp;
                firstText.charAt(textTruncation) === "^") {
                firstText = firstText.substr(0, textTruncation);
            }
            if (firstText.toUpperCase() !== newtext.toUpperCase()) {
                var start_pos = newtext.indexOf("(");
                if (-1 !== start_pos) {
                    if (0 === firstText.search(newtext.substring(0, start_pos))) return true;
                }
                return "!=TextTRIM";
            }
        } else if (newtext &amp;&amp; !DgoProfile.has_scroll(obj)) {
            return "!=TextTRIM";
        }
        return true;
    },
    Eep_generate: function (object) {
        try {
            var eep_textTruncation = 50;
            var obj = object.nodeType === 3 ? object.parentNode : object;
            var options = 1 + (eep_useInnerText ? 2 : 0);
            var eepString = "eep_path=\"" + this.Eep_getPathString(obj, 1) + "\";\r\n";
            eepString += "eep_options=" + options /*+ ';eep_version="6.1.1"*/ + ";\r\n";
            eepString += "eep_atts={" + this.Eep_generateAttsString_(obj, options, eep_textTruncation) + "};\r\n";
            eepString += "\r\n" + this.Eep_generateExtraInfo_(obj);
            return eepString;
        } catch (err) { exception_debugging(err); }
        return "error";
    },
    Eep_qaElement_: function (obj, atts, options) {
        if (!obj) return false;
        try {
            var match_width = true;
            var rc;
            var obj_Rect = obj.getBoundingClientRect();
            var objht = parseInt(obj_Rect.bottom) - parseInt(obj_Rect.top);
            var objwt = parseInt(obj_Rect.right) - parseInt(obj_Rect.left);
            if (atts.tagName) {
                if (!obj.tagName || (obj.tagName !== atts.tagName)) {
                    return "!=TAG";
                }
            }
            var spl_attr_avl_mismatch = false;
            for (var i in this.Eep_specialAttributes_) {
                if (atts[this.Eep_specialAttributes_[i]]) {
                    var val_id = this.Eep_getAttribute_(obj, this.Eep_specialAttributes_[i]);
                    if (val_id &amp;&amp; (val_id === atts[this.Eep_specialAttributes_[i]])) {
                        return true;
                    }
                    spl_attr_avl_mismatch = true;
                }
            }
            if (spl_attr_avl_mismatch === true) {
                return "!=SAA";
            }
            if (true !== (rc = this.Eep_qaInputElement_(obj, atts))) {
                return rc;
            }
            if (atts.src) {
                if (!obj.src || (DgoUtils.extract_img_src(obj.src) !== atts.src)) {
                    return "!=SRC";
                } else {
                    match_width = false;
                }
            }
            var newtext = this.Eep_getFirstTextNodeValue_(obj, 50, true /*with delimiter*/);
            if (!newtext) {
                newtext = this.Eep_getElementInnerValue_(obj, 50, true);
            }
            if (!options || options &amp;&amp; options.eep_use_text === "true" &amp;&amp; newtext) {
                if (true !== (rc = this.Eep_qaElementText_(obj, atts, options))) {
                    return rc;
                } else {
                    match_width = false;
                }
            }
            if (atts.id) {
                if ((obj.id &amp;&amp; obj.id !== atts.id &amp;&amp; !this.partial_id_comp_(atts.id, obj.id)) || !obj.id) {
                    return "!=ID";
                } else {
                    match_width = false;
                }
            } else if (obj.id) {
                var el;
                var doc = DgoProfile.get_doc_from_elem(obj);
                var all_elems = doc.getElementsByTagName("*");
                //if (doc &amp;&amp; doc.all &amp;&amp; (el = doc.all[obj.id]) &amp;&amp; typeof el.length === "number" &amp;&amp; el.length &gt; 1)
                if (all_elems &amp;&amp; (el = all_elems[obj.id]) &amp;&amp; (typeof el.length === "number") &amp;&amp; (el.length &gt;= 1)) {
                    // mySAP, i.e., has lots of duplicate IDs
                } else {
                    return "!=ID";
                }
            }
            if (atts.ht &amp;&amp; atts.wt &amp;&amp; match_width) {
                if (!objht || !objwt ||
                    (match_width &amp;&amp; (objwt &lt;= (atts.wt - 2) || objwt &gt;= (atts.wt + 2))) ||
                    (objht &lt;= (atts.ht - 2) || objht &gt;= (atts.ht + 2))) {
                    return "!=DIMENSIONS";
                }
            }
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    partial_id_comp_: function (rec_id, rerec_id) {
        if (!rec_id || !rerec_id) return false;
        try {
            var sub_str_id_1 = "";
            var sub_str_id_2 = "";
            if (ignore_ids) return true;
            if (ignore_dynamic_ids === 1) {
                for (var i = 0; i &lt; rec_id.length; i++) {
                    if ((i &lt; rerec_id.length) &amp;&amp; !isNaN(rerec_id.charAt(i))) {
                        sub_str_id_2 = rerec_id.substring(0, i);
                    }
                    if (!isNaN(rec_id.charAt(i))) {
                        sub_str_id_1 = rec_id.substring(0, i);
                        break;
                    }
                }
            }
            if (sub_str_id_1 === sub_str_id_2) {
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    Eep_getRe4FirstText_: function (first_text, options) {
        if (!options || !options.eep_first_text_re || typeof options.eep_first_text_re.exec !== "function") return null;

        var rc = options.eep_first_text_re.exec(first_text);
        if (!rc || rc.length &lt;= 1) return "";

        var ret_val = "";
        for (var i = 1; i &lt; rc.length; ++i) {
            ret_val += rc[i];
        }
        return ret_val;
    },
    Eep_getElementRef: function (obj) {
        var coll = this.Eep_generateCollectionObject_(obj) || { n: "", i: "0", ii: "-1" };
        return new ElementRef(this.Eep_getPathString(obj), /* Producer compatible */ coll.n, coll.i, coll.ii, this.Eep_generate(obj));
    },
    Eep_resolveId_: function (id) {
        if (!id) return null;
        try {
            //if (window.document.all &amp;&amp; window.document.all[id] &amp;&amp;
            //    typeof window.document.all[id].length === "number" &amp;&amp;
            //    window.document.all[id].length !== 1) {
            //    return window.document.all[id].length;
            var all_elems = window.document.getElementsByTagName("*");
            if (all_elems &amp;&amp; all_elems[id] &amp;&amp; typeof all_elems[id].length === "number" &amp;&amp;
                window.all_elems[id].length !== 1) {
                return all_elems[id].length;
            }
            return window.document.getElementById(id);
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveName_: function (name, tagname /*NC4 only*/, flagUnique) {
        if (!name) return null;
        try {
            var objs = window.document.getElementsByName(name);
            return objs.length === 0 || flagUnique &amp;&amp; objs.length &gt; 1 ? null : objs[0];
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveInputValue_: function (tagname, type, name, value) {
        if (tagname !== "INPUT" &amp;&amp; type !== "radio") return null;
        try {
            var objs = window.document.getElementsByName(name);
            if (objs.length === 0) return null;

            var obj;
            for (var i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                if (obj.type === "radio" &amp;&amp; obj.value === value) return obj;
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveSimple: function (path, options, base_el) {
        var el;
        try {
            el = window.document.body;
            if (path === "") return el;
            el = base_el || el;
            var opt = options || 0;
            var path_bits = path.split(":");
            var i, idx, children, ii, child, type;
            for (i = 0; el &amp;&amp; i &lt; path_bits.length; ++i) {
                idx = path_bits[i] - 0;
                children = opt &amp; 1 ? el.childNodes : el.children || el.childNodes;
                el = null;
                for (ii = 0; el === null &amp;&amp; ii &lt; children.length; ++ii) {
                    child = children[ii];
                    type = opt &amp; 1 &amp;&amp; child.tagName &amp;&amp; child.tagName === "!" ? 8 : child.nodeType;
                    if (type === 1 &amp;&amp; idx === 0) {
                        el = child;
                    } else {
                        if (opt &amp; 1) {
                            if (type === 1)--idx;
                        } else {
                            if (type !== 3)--idx;
                        }
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return el;
    },
    Eep_resolveByDirectPath: function (path) {
        var el;
        try {
            el = window.document.body;
            if (!path) {
                return el;
            }
            var split_path = path.split(":");
            var i, idx;
            for (i = 0; el &amp;&amp; i &lt; split_path.length; ++i) {
                idx = split_path[i] - 0;
                if (idx &lt; el.children.length) el = el.children.item(idx);
            }
        } catch (err) { exception_debugging(err); }
        return el;
    },
    Eep_generateExtraInfo_: function (obj) {
        if (!obj) return "";

        var str = "";
        var tagname = obj.tagName;
        var doc = DgoProfile.get_doc_from_elem(obj);
        if (doc) {
            var tag_coll = doc.getElementsByTagName(tagname);  //test for multiple frame case
            // debugger;
            if (tag_coll) {
                var tag_coll_length = tag_coll.length;
                for (var i = 0; i &lt; tag_coll_length; i++) {
                    var child = tag_coll.item(i);
                    if (obj === child) {
                        str = "eep_elem_index=\"" + i + "\";eep_elem_tag=\"" + tagname + "\";";
                        break;
                    }
                }
            }
        }
        str += "eep_frame_name=\"" + window.name + "\";eep_frame_src=\"" + "" + "\";";
        return str;
    },
    Eep_getPathString: function (obj, opts) {
        var options = opts || 0;
        if (options &amp; 4 /*top-down*/) return this.Eep_getPathString2_(obj, options);

        var er = "";    // datango simple element reference
        var x = obj;   // element
        var /* i, */ ii, p, children, kk, child;

        if (x.nodeType === 3 /*text*/ ||
            (x.tagName &amp;&amp; x.tagName !== "APPLET" &amp;&amp; x.tagName !== "EMBED" &amp;&amp; (x.tagName !== x.tagName.toUpperCase() /*XUL*/ || x.toString().indexOf("XUL") &gt;= 0))) {
            x = x.parentNode;
        }

        while (x &amp;&amp; (p = x.parentNode) !== null &amp;&amp; typeof x.tagName === "string" &amp;&amp; x.tagName !== "BODY" &amp;&amp; x.tagName !== "FRAMESET") {
            children = options &amp; 1 ?
                p.childNodes /*W3C Std*/ :
                p.children /*IE*/ || p.childNodes /*W3C Std*/;
            kk = -1;

            for (ii = 0; child !== x &amp;&amp; ii &lt; children.length; ++ii) {
                child = children[ii];

                if (options &amp; 1) {
                    if (child.nodeType === 1 &amp;&amp; child.tagName !== "!")++kk;
                } else {  // Producer compatible
                    if (child.nodeType !== 3)++kk; // DOM Text Node
                }
            }

            if (child !== x) return "";

            if (er) er = ":" + er;
            er = kk + er;
            x = p;
        }
        return er;
    },
    Eep_getFirstTextNode_: function (obj) {
        var children = obj.childNodes || [];  // DOM child collection with text nodes
        var node;

        for (var i = 0; i &lt; children.length; ++i) {
            node = children[i];
            if (node.nodeType &amp;&amp; node.nodeType === 3 &amp;&amp; node.nodeValue.search(this.Eep_getFirstTextNodeRE_) &gt;= 0) {
                return node;
            }
        }
        return null;
    },
    Eep_getFirstElementNode_: function (obj) {
        var children = obj.childNodes || [];  // DOM child collection with text nodes
        var node;

        for (var i = 0; i &lt; children.length; ++i) {
            node = children[i];
            if (node.nodeType &amp;&amp; DgoUtils.is_valid_str(node.innerText)) {
                return node;
            }
        }
        return null;
    },
    Eep_generateParentsString_: function (obj, options, tags4text) {
        return "";  // Now we don't require parent info as ReRecognition doesn't have top down approach
        //if (!obj || obj.tagName === "BODY" || obj.tagName === "FRAME" || !obj.parentNode) return "";

        //var str = "";
        //var p = obj.parentNode;

        //while (p &amp;&amp; p.tagName !== "BODY" &amp;&amp; p.tagName !== "FRAME") {
        //    str += (",\r\n{" + Eep_generateAttsString_(p, frame_, options, "", 0) + "}");
        //    p = p.parentNode;
        //}
        //return str.substr(3);
    },
    Eep_generateSiblingsString_: function (obj) {
        if (!obj || !obj.parentNode || obj.tagName === "BODY" || obj.tagName === "FRAME") {
            return "";
        }
        var str = "";
        var children = obj.parentNode.childNodes;
        var child;
        for (var i = 0; i &lt; children.length; ++i) {
            child = children[i];
            if (child.nodeType === 1 &amp;&amp; child.tagName !== "!") {  // exclude comments
                if (child.tagName.charAt(0) !== "/") {
                    str += child === obj ?
                        ":_" + children[i].tagName + "_" :
                        ":" + children[i].tagName;
                }
            }
        }
        return str.substr(1);
    },
    Eep_generateCollectionString_: function (x) {
        var ret_val = this.Eep_generateCollectionObject_(x);
        return ret_val ?
            'n:"' + ret_val.n + '",i:' + ret_val.i + ',ii:' + ret_val.ii :
            'n:"",i:0,ii:-1';
    },
    Eep_generateCollectionObject_: function (x) {
        if (!x) return null;
        switch (x.tagName) {
            case "INPUT":
            case "TEXTAREA":
            case "SELECT":
            case "OPTION":
            case "BUTTON":
            case "FORM":
                return this.Eep_getElementCollection_("forms", x);
            case "IMG":
                return this.Eep_getElementCollection_("images", x);
            case "A":
                return this.Eep_getElementCollection_((x.name ? "anchors" : "links"), x);
            case "DIV":
                return this.Eep_getElementCollection_("layers", x);
            case "APPLET":
                return this.Eep_getElementCollection_("applets", x);
            case "EMBED":
                return this.Eep_getElementCollection_("embeds", x);
            default:
                return null;
        }
    },
    Eep_getElementCollection_: function (collName, x) {
        var coll = window ? window.document[collName] : null;

        if (typeof coll === "object" &amp;&amp; coll &amp;&amp; typeof coll.length === "number") {
            var cmp;
            var ii;
            for (var i = 0; i &lt; coll.length; ++i) {
                cmp = coll[i];

                if (cmp === x) {
                    return { n: collName, i: "" + i, ii: "-1" };
                } else if (typeof cmp === "object" &amp;&amp; typeof cmp.length === "number") {
                    for (ii = 0; ii &lt; cmp.length; ++ii) {
                        if (cmp[ii] === x) {
                            return { n: collName, i: "" + i, ii: "" + ii };
                        }
                    }
                }
            }
        }
        return { n: "", i: "0", ii: "-1" };
    },
    Eep_getPathString2_: function (obj, opts) {
        var options = opts || 0;
        var er = "";
        var x = obj;
        var i, ii, p, children, kk, child;

        if (x.nodeType === 3 /*text*/ ||
            (x.tagName &amp;&amp; x.tagName !== "APPLET" &amp;&amp; x.tagName !== "EMBED" &amp;&amp; (x.tagName !== x.tagName.toUpperCase() /*XUL*/ || x.toString().indexOf("XUL") &gt;= 0))) {
            x = x.parentNode;
        }

        var body;
        if (x &amp;&amp; x.ownerDocument) {
            body = x.ownerDocument.body;
        } else {
            p = x;
            while (p &amp;&amp; p.tagName !== "BODY") {
                p = p.parentNode;
            }
            if (!p) return "EPerr:above_body";
            body = p;
        }
        var ret_val = this.Eep_getPathString2_rek_(body, x, opts);
        return ret_val === false ? "EPerr:not_found" : ret_val;
    },
    Eep_getPathString2_rek_: function (parent, obj, options) {
        if (parent === obj) return "";
        var children = options &amp; 1 ?
            parent.childNodes /*W3C Std*/ :
            parent.children /*IE*/ || parent.childNodes /*W3C Std*/;
        var kk = -1;
        var i, child, rc;
        for (i = 0; i &lt; children.length; ++i) {
            child = children[i];
            if (options &amp; 1) {
                if (child.nodeType === 1 &amp;&amp; child.tagName !== "!")++kk;
            } else {
                if (child.nodeType !== 3)++kk;
            }

            if (child.nodeType === 1 &amp;&amp; child.tagName !== "!" &amp;&amp;
                false !== (rc = this.Eep_getPathString2_rek_(child, obj, options))) {
                return rc ? kk + ":" + rc : "" + kk;
            }
        }
        return false;
    },
    Eep_getNodeHtml: function (obj) {
        if (typeof DHtml_getNodeHtml === "function") return DHtml_getNodeHtml(obj);
        if (!obj) return "(null)";
        if (typeof obj !== "object") return "\"" + obj + "\" [" + typeof obj + "]";
        if (obj.tagName) return obj.tagName;
        if (obj.nodeType) return "(nodetype=" + obj.nodeType + ")";
        return "(?)";
    },
    Eep_qaInputElement_: function (obj, atts) {
        if (!obj) return false;
        try {
            if (atts.type) {
                if (!obj.type || (obj.type &amp;&amp; obj.type !== atts.type)) {
                    return "!=TYPE";
                }
            } else if (obj.type) {
                return "!=TYPE";
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    }
};
// =============================================== Utils ================================================ //
DGO.Utils = function () { };

DGO.Utils.prototype = {
    use_old_version: false,
    extract_src_from_string: function (frm_src, startToken, endToken) {
        try {
            var end_pos = frm_src.indexOf(endToken);
            if (-1 === end_pos) end_pos = frm_src.length - 1;
            var start_pos = frm_src.lastIndexOf(startToken, end_pos);
            start_pos = -1 === start_pos ? 0 : start_pos + 1;
            var res = frm_src.substring(start_pos, end_pos);
            return res;
        } catch (err) { exception_debugging(err); }
        return frm_src;
    },
    extract_img_src: function (frm_src) {
        try {
            var lastIndexOfToken = "/";
            var remove_strings = ["_hover"];
            if (frm_src) {
                var end_pos = frm_src.length;
                var start_pos = frm_src.lastIndexOf(lastIndexOfToken);
                start_pos = -1 === start_pos ? 0 : start_pos + 1;
                var res = frm_src.substring(start_pos, end_pos);
                for (var i = 0; i &lt; remove_strings.length; i++) {
                    res = res.replace(remove_strings[i], "");
                }
                return res;
            }
        } catch (err) { exception_debugging(err); }
        return frm_src;
    },
    is_valid_str: function (str) {
        return typeof str !== "undefined" &amp;&amp; str !== null &amp;&amp; str !== "" &amp;&amp; str !== "Untitled";
    },
    trim: function (inputStr) {
        // This function is used for trim leading and trailing space in a string.
        // It will also remove new line and tabs present in a string.
        return this.is_valid_str(inputStr) ? inputStr.replace(/^\s+|\s+$/g, "").replace(/[\r\n\x0B\x0C\u0085\u2028\u2029]+/g, " ") : "";
    },
    get_tree_item_from_id: function (obj_id) {
        try {
            var obj_id_node = window.document.getElementById(obj_id);
            if (typeof obj_id_node === "object" &amp;&amp; obj_id_node !== null) {
                var elmcoll = window.document.getElementsByName(obj_id);
                if (elmcoll.length &lt; 2) return obj_id_node;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_frame_with_name: function (frame_name) {
        try {
            if (window.document.document.title === frame_name) return frame_name;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    to_hex: function (n) {
        try {
            n = parseInt(n, 10);
            if (isNaN(n)) return "00";
            n = Math.max(0, Math.min(n, 255));
            return "0123456789ABCDEF".charAt((n - n % 16) / 16) + "0123456789ABCDEF".charAt(n % 16);
        } catch (err) { exception_debugging(err); }
        return "00";
    },
    rgb_to_hex: function (str) {
        try {
            var font_color = "#";
            var start = str.indexOf("(");
            var end = str.indexOf(",");
            var i = 0;
            while (i &lt; 3) {
                var r = str.substring(start + 1, end);
                font_color = font_color + this.to_hex(r);
                start = end;
                str = str.replace(",", ";");
                end = str.indexOf(",");
                if (end === -1) end = str.indexOf(")");
                i++;
            }
            return font_color;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    is_in_array: function (element, array) {
        if (!this.use_old_version) {
            try {
                return array.indexOf(element) &gt;= 0;
            } catch (err) {
                this.use_old_version = true;
            }
        }
        for (var i = 0; i &lt; array.length; i++) {
            if (array[i] === element) return true;
        }
        return false;
    },
    get_ie_version: function () {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        if (msie &gt; 0) {
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident &gt; 0) {
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        var edge = ua.indexOf('Edge/');
        if (edge &gt; 0) {
            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        return 11;
    },
    get_element_by_classname: function (node, classname) {
        try {
            if (node) {
                if (node.getElementsByClassName) {
                    return node.getElementsByClassName(classname);
                } else {
                    var coll = [];
                    var all = node.getElementsByTagName("*");
                    for (var i = 0; i &lt; all.length; ++i) {
                        var elem = all[i];
                        if (elem &amp;&amp; elem.className &amp;&amp; this.element_has_classname(elem, classname)) {
                            coll.push(elem);
                        }
                    }
                    return coll;
                }
            }
        } catch (err) { exception_debugging(err); }
        return [];
    },
    element_has_classname: function (element, classlist) {
        if (element) {
            var classes = classlist.split(" ");
            var match = classes.length &gt; 0;
            if (element.classList) {
                for (var i = 0; i &lt; classes.length; ++i) {
                    match = match &amp;&amp; element.classList.contains(classes[i]);
                    if (!match) return false;
                }
            } else {
                var elem_classlist = " " + element.className + " ";
                for (var i = 0; i &lt; classes.length; ++i) {
                    match = match &amp;&amp; elem_classlist.indexOf(" " + classes[i] + " ") &gt;= 0;
                    if (!match) return false;
                }
            }
            return match;
        }
        return false;
    },
    get_zindex: function (element) {
        try {
            while (element &amp;&amp;  element.nodeType === 1) {
                var cstyle = window.getComputedStyle(element);
                if (cstyle.getPropertyValue("position") !== "static") {
                    var z = cstyle.getPropertyValue("z-index");
                    if (!isNaN(z)) return parseInt(z);
                }
                element = element.parentNode;
            }
        } catch (err) { exception_debugging(err); }
        return 0;
    },
    get_role: function (element) {
        return (element &amp;&amp; (element.getAttribute("role") || element.getAttribute("type")));
    },
    has_popup: function (element) {
        return (element &amp;&amp; element.getAttribute("aria-haspopup"));
    },
    search_by_className_exact: function (classname, array) {
        if (!classname || !array) return false;
        for (var i = 0; i &lt; array.length; i++) {
            if (classname &amp;&amp; classname === array[i]) return true;
        }
        return false;
    },
    partial_search: function (classname, array) {
        if (!classname || !array) return false;
        for (var i = 0; i &lt; array.length; i++) {
            if (classname &amp;&amp; classname.search(array[i]) !== -1) return true;
        }
        return false;
    },
    search_by_className: function (coll, classname) {
        if (!coll || !classname) return null;
        for (var i = 0; i &lt; coll.length; i++) {
            var elem = coll[i];
            if (elem.className.search(classname) !== -1) return elem;
        }
        return null;
    },
    get_elements_by_tagname_and_attr: function (element, tag_name, attr_name, attr_vals) {
        if (!element) return null;
        var elems = [];
        var tag_coll = element.getElementsByTagName(tag_name);
        for (var i = 0; i &lt; tag_coll.length; i++) {
            var elem = tag_coll[i];
            if (this.is_in_array(elem.getAttribute(attr_name), attr_vals)) {
                elems.push(elem);
            }
        }
        return elems;
    },
    get_elements_by_classname_and_attr: function (element, class_name, attr_name, attr_vals) {
        if (!element) return null;
        var elems = [];
        var class_coll = this.get_element_by_classname(element, class_name);
        for (var i = 0; i &lt; class_coll.length; i++) {
            var elem = class_coll[i];
            if (this.is_in_array(elem.getAttribute(attr_name), attr_vals)) {
                elems.push(elem);
            }
        }
        return elems;
    },
    search_by_class: function (elem, class_coll) {
        for (var i = 0; i &lt; class_coll.length; i++) {
            var act_class_coll = DgoUtils.get_element_by_classname(elem, class_coll[i]);
            if (act_class_coll &amp;&amp; act_class_coll.length) return act_class_coll;
        }

        return null;
    },
    get_topmost_element: function (elements) {
        if (!elements || elements.length &lt;= 0) return null;

        var max_i = -1;
        var max_z = -10000;
        for (var i = 0; i &lt; elements.length; ++i) {
            var element = elements[i];
            if (this.is_visible_displayed(element)) {
                var z = DgoUtils.get_zindex(element);
                if (z &gt; max_z) {
                    max_i = i;
                    max_z = z;
                }
            }
        }
        return max_i === -1 ? null : elements[max_i];
    },
    is_visible_displayed: function (element) {
        if (!element || element.nodeType !== 1) return true;
        var cstyle = window.getComputedStyle(element);
        if (cstyle &amp;&amp; (cstyle.display === "none" || cstyle.visibility === "hidden")) return false;
        return this.is_visible_displayed(element.parentNode);
    },
    find_parent_by_tagname_and_attr: function (element, tag_name, attr_name, attr_vals) {
        if (!element) return null;
        var parent = element.parentNode;
        for (var i = 0; i &lt; 10; i++) {
            if (!parent) break;
            if (parent.tagName === tag_name &amp;&amp; this.is_in_array(parent.getAttribute(attr_name), attr_vals)) {
                return parent;
            }
            parent = parent.parentNode;
        }
        return null;
    },
    get_title: function () {
        return document.title;
    },
    get_url: function () {
        return window.location.href;
    },
    get_valid_classname: function (e) {
        if (e.className &amp;&amp; typeof e.className === "string") {
            return e.className;            
        }
        return "";
    }
    
};
// ================================== EXAMPLE CODE FOR LIBRARY AND PROFILE EXTENSIONS ================================== //
//// ----- common script
//function extendObj(dst, src) {
//    for (var i in src) {
//        if (src.hasOwnProperty(i)) dst[i] = src[i];
//    }
//}

//var DGO = window.DGO || {};

//DGO.Base = function() {}

//DGO.Base.prototype = {
//    check_handler: function() {
//        return "base check";
//    }
//}
////----- library script
//DGO.Extended = function() {
//    DGO.Base.call(this);
//}

//DGO.Extended.prototype = new DGO.Base();

//extendObj(DGO.Extended.prototype, {
//    check_handler: function() {
//        return "ext check";
//    }
//});
//var DgoProfile = new DGO.Extended();

////----- profile script
//DGO.ExtendedProfile = function() {
//    DGO.Extended.call(this);
//}

//DGO.ExtendedProfile.prototype = new DGO.Extended();

//extendObj(DGO.ExtendedProfile.prototype, {
//    check_handler: function() {
//        return "ext profile check";
//    }
//});
//DgoProfile = new DGO.ExtendedProfile();

//console.log("Hi!");
//console.log("base: " + DGO.Base.prototype.check_handler());
//console.log("ext: " + DGO.Extended.prototype.check_handler());
//console.log("ext profile: " + DGO.ExtendedProfile.prototype.check_handler());
//console.log("profile: " + DgoProfile.check_handler());

//var DGO = window.DGO || {};
DGO.Effect = function () { };

DGO.Effect.prototype = {
    overlay: {
        element: null,
        id: "help4-recording-path-quality-highlight",
        active: false,
        //capture_rect_css: "position: absolute; z-index: 1000001; pointer-events: none; transform: translate(-3px, -3px); border: solid 3px #ffc000; background-color: rgba(255,192,0,0.15);",
        //safe_css: "border-color: #408600; background-color: rgba(64,134,0,0.15);",
        timestamp: 0
    },

    activate: function () {
        if (this.overlay.active === true) return;
        //console.log("DgoEffect activated");
        this.overlay.active = true;
        this.overlay.timestamp = Date.now();
        if (document.addEventListener) {
            document.addEventListener("mouseover", this.mouse_effect_handler);
        } else if (document.attachEvent) {
            document.attachEvent("mouseover", this.mouse_effect_handler);
        }
    },
    deactivate: function () {
        if (this.overlay.active === false) return;
        //console.log("DgoEffect deactivated");
        this.overlay.active = false;
        this.get_overlay().style.visibility = "hidden";
        if (document.removeEventListener) {
            document.removeEventListener("mouseover", this.mouse_effect_handler);
        } else if (document.detachEvent) {
            document.detachEvent("mouseover", this.mouse_effect_handler);
        }
    },
    get_overlay: function () {
        return this.overlay.element ? this.overlay.element : this.create_overlay();
    },
    create_overlay: function () {
        var overlay_element = window.document.getElementById(this.overlay.id);
        if (overlay_element) {
            this.overlay.element = overlay_element;
            return overlay_element;
        }
        //console.log("creating new overlay");
        overlay_element = window.document.createElement("div");
        overlay_element.id = this.overlay.id;
        this.overlay.element = window.document.body ? window.document.body.appendChild(overlay_element) : null;
        return this.overlay.element;
    },
    mouse_effect_handler: function (e) {
        try {
            e = e || event;
            if (!e || !e.target) return;

            if (e.type === "mouseover") {
                //console.log("mouseover effect");
                if (DgoEffect.overlay.active === false || typeof generate_xray_path !== "function") return;  // needs xRay.js
                var p = generate_xray_path(e.target, Help4R.selector.Shell);  // xRay.js
                var target_pos = (p &amp;&amp; p.elem) ? p.elem.getBoundingClientRect() : e.target.getBoundingClientRect();

                var overlay_style = DgoEffect.get_overlay().style;
                overlay_style.cssText = _HELP4_CONTROL_CAPTURERECT_CSS + ((p &amp;&amp; p.safe === 1.0) ? _HELP4_SAFE_CSS : "");
                overlay_style.visibility = "";
                overlay_style.left = target_pos.left.toString() + "px";
                overlay_style.top = target_pos.top.toString() + "px";
                overlay_style.width = (target_pos.right - target_pos.left).toString() + "px";
                overlay_style.height = (target_pos.bottom - target_pos.top).toString() + "px";

                //console.log("over " + e.target.tagName + ":" + e.target.className + " pos: " + target_pos.left + "x" + target_pos.top + ((p &amp;&amp; p.elem) ? " (selector element)" : " (event target)"));
                //console.log("effect active: " + DgoEffect.overlay.active + " timestamp: " + DgoEffect.overlay.timestamp);
                //console.log("rule: " + p.rule.toString());
                //console.log("selector: Help4R.selector.Shell"));

                // prevent other mouseover effects
                e.cancelBubble = true;
            }
        } catch (err) { exception_debugging(err); }
    }
};
//var DgoEffect = DgoEffect || new DGO.Effect();

// to active the mouse over effect call:
//DgoEffect.activate();
// to deactivate call:
//DgoEffect.deactivate();


// include file: ../HTMLBasic/script.js

// declared in final profile
//var EepUtils = new DGO.BasicEepUtils();
//var DgoUtils = new DGO.Utils();

// HTML Basic
DGO.HTMLBasic = function () {
    DGO.Base.call(this);
};

DGO.HTMLBasic.prototype = new DGO.Base();

extendObj(DGO.HTMLBasic.prototype, {
    element_rect: null,
    elem_xtype: function (e) {
        var type = this.elem_xtype_from_role(e);
        if (!type) {
            type = this.elem_xtype_from_class(e);
        }
        return type;
    },

    elem_xtype_from_role: function (e) {
        var type = DgoUtils.get_role(e);
        if (type &amp;&amp; DgoUtils.is_in_array(type, DgoProfile.get_valid_roles()) &amp;&amp; !DgoProfile.is_exception_element(e, type)) {
            type = this.correct_type(type, e);
            if (type &amp;&amp; this.check_handler(type)) {
                type = this.convert_to_compat(type);
                return type;
            }
        }
        return "";
    },

    elem_xtype_from_class: function (e) {
        return DGO.Base.prototype.elem_xtype.call(this, e);
    },

    correct_type: function(type, e) {
        if (type === "button") {
            var parent = e.parentNode;
            var elmpopup = DgoUtils.has_popup(e);
            var parentpopup = DgoUtils.has_popup(parent);
            if (elmpopup || parentpopup) {
                type = "dropdown";
            }
        } else if (type === "radio" || type === "checkbox") {
            var width = parseInt(this.element_rect.right) - parseInt(this.element_rect.left);
            var height = parseInt(this.element_rect.bottom) - parseInt(this.element_rect.top);
            if (width &gt; (height * 1.5)) {
                type = "labeltext";
            }
        }
        return type;
    },
    get_valid_roles: function () {
        return [
            "link",
            "button",
            "text",
            "labeltext",
            "checkbox",
            "submit",
            "tab",
            "rowheader",
            "option",
            "radio",
            "combobox",
            "menuitem",
            "search"
        ];
    },
    get_role_depth: function () {
        return 3;
    },
    is_exception_element: function(elem, role, e) {
        return false;
    },

    check_handler: function (type) {
        var valid_htmlbasic_tags = [
            "A",
            "BUTTON",
            "DIV",
            "HScrollBtnR",
            "HScrollBtnL",
            "HScrollBar",
            "HScrollAreaR",
            "HScrollAreaL",
            "INPUTpassword",
            "INPUTsubmit",
            "INPUTbutton",
            "INPUTcheckbox",
            "INPUTcheckboxOn",
            "INPUTcheckboxOff",
            "INPUTfile",
            "INPUTradio",
            "INPUTsearch",
            "INPUTtext",
            "dropdown",
            "IMGA:",
            "IMGSPAN:",
            "SELECT",
            "SPAN",
            "TEXTAREA",
            "VScrollAreaB",
            "VScrollAreaT",
            "VScrollBar",
            "VScrollBtnB",
            "VScrollBtnT"];
        return DgoUtils.is_in_array(type, valid_htmlbasic_tags) ||
            DGO.Base.prototype.check_handler.call(this, type);
    },
    get_xray_screen_id: function () {
        try {
            return _getScreenId();
        } catch (err) { exception_debugging(err); }
        return "";
    },
    convert_to_compat: function (type) {
        var new_type = type;

        switch (type) {
            case "link":
            case "labeltext":
            case "option":
                new_type = "Hrefarea";
                break;
            case "dropdown":
                new_type = "dropdown";
                break;
            case "submit":
            case "button":
                new_type = "Button";
                break;
            case "text":
            case "search":
                new_type = "Edit";
                break;
            case "tab":
                new_type = "Pagetab";
                break;
            case "checkbox":
                new_type = "Checkbox";
                break;
            case "radio":
                new_type = "Radio Button";
                break;
            case "rowheader":
                new_type = "Checkbox_1";
                break;
        }
        if (new_type !== type) return new_type;
        return new_type !== type ? new_type : DGO.Base.prototype.convert_to_compat.call(this, type);
    },
    empty: function () {
        return "";      // key can be removed after DPS-44325
    }
});
// do not use this library as full profile
var DgoProfile = new DGO.HTMLBasic(); // use DGO.HTMLBasic in final profile
var DgoEep = new DGO.BaseEep();
var EepUtils = new DGO.BaseEepUtils();
var DgoUtils = new DGO.Utils();
var DgoProcessing = new DGO.BaseProcessing();
// ---------------------------------------------------
DGO.HtmlBasicHTMLElementRecognition = function () {
    DGO.BaseHTMLElementRecognition.call(this);
};
DGO.HtmlBasicHTMLElementRecognition.prototype = new DGO.BaseHTMLElementRecognition();

extendObj(DGO.HtmlBasicHTMLElementRecognition.prototype, {
    get_element_from_point: function (point_x, point_y) {
        try {
            var get_elem = DGO.BaseHTMLElementRecognition.prototype.get_element_from_point.call(this, point_x, point_y);
            var elem = this.get_role_elem(this.element);
            var ret = DgoUtils.get_role(elem);
            if (ret &amp;&amp; DgoUtils.is_in_array(ret, DgoProfile.get_valid_roles()) &amp;&amp; !DgoProfile.is_exception_element(elem, ret, this.element)) {
                this.element = elem;
                this.has_role = true;
                return true;
            }
            return get_elem;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_bc_rect: function () {
        this.element_rect = this.element.getBoundingClientRect();
        var role = DgoUtils.get_role(this.element);            
        if (role === "checkbox" || role === "radio") {
            var elm_rect = this.element_rect;
            var height = parseInt(elm_rect.bottom) - parseInt(elm_rect.top);
            var rect_right = DgoProfile.offset_rect(elm_rect, 0, 0);
            rect_right.right = parseInt(rect_right.left) + parseInt(height - 5);
            if (this.pt_in_rect(this.client_x, this.client_y, rect_right)) {
                this.element_rect = DgoProfile.offset_rect(rect_right, this.frame_offset_x, this.frame_offset_y);
                return true;
            }
        }
        return this.correct_bc_rect() || DGO.BaseHTMLElementRecognition.prototype.get_bc_rect.call(this);
    },
    correct_bc_rect: function () {
        return false;
    },
    pt_in_rect: function(x, y, rect) {
        return (x &gt;= parseInt(rect.left) &amp;&amp;
                x &lt;= parseInt(rect.right) &amp;&amp;
                y &gt;= parseInt(rect.top) &amp;&amp;
                y &lt;= parseInt(rect.bottom));
    },
    get_role_elem: function(elem) {
        for (var iter = 0; iter &lt; DgoProfile.get_role_depth(); iter++) {
            var role = DgoUtils.get_role(elem);
            if (role &amp;&amp; DgoUtils.is_in_array(role, DgoProfile.get_valid_roles())) {
                break;
            }
            if(elem !== null){
                elem = elem.parentNode;
            }
        }
        return elem;
    },
    get_ancestor: function (depth, elem) {
        try {
            var e = elem;
            // if depth is positive set human to immediate parent
            for (var i = 0; i &lt; depth &amp;&amp; e; ++i) {
                e = e.parentNode;
            }
            // if depth is negative set human to immediate childa
            for (var i = depth; i &lt; 0 &amp;&amp; e &amp;&amp; e.children; ++i) {
                e = e.children[0];
            }
            return e;
        } catch (err) { exception_debugging(err); }

        return null;
    },
    correct_my_element: function (elem, goToFamily) {
        for (var i = 0; i &lt; goToFamily.length; ++i) {
            var depth_list = goToFamily[i]["depth"];

            for (var j = 0; j &lt; depth_list.length; ++j) {

                var family_node = this.get_ancestor(depth_list[j], elem);

                if (family_node) {
                    try {
                        var class_name = family_node.getAttribute(Object.keys(goToFamily[i])[0]);

                        if (class_name &amp;&amp; class_name.indexOf(goToFamily[i][Object.keys(goToFamily[i])[0]]) != -1) {
                            return family_node;
                        }
                    } catch (err) { exception_debugging(err); }
                }
            }
        }
        return elem;
    }
});
var HTMLElementRecognition = new DGO.HtmlBasicHTMLElementRecognition();


DGO.XRayHTMLElementRecognition = function () {
    DGO.BaseHTMLElementRecognition.call(this);
};
DGO.XRayHTMLElementRecognition.prototype = new DGO.BaseHTMLElementRecognition();
extendObj(DGO.XRayHTMLElementRecognition.prototype, {
    xray_path: "",
    path_safe: 1,
    get_element_from_point: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;
            try {
                var wpb_xray = generate_xray_path(this.element, Help4R.RpickSelector().selector);  // xRay.js
                if (DgoUtils.is_valid_str(wpb_xray.rule)) {
                    //window.document.body.setAttribute("wpb_xray_hotspotAnchor", wpb_xray.rule, 0);
                    this.xray_path = "xray=\"" + window.btoa(JSON.stringify(wpb_xray.rule)) + "\";xps=\"" + wpb_xray.safe + "\";";
                    this.path_safe = wpb_xray.safe;
                    this.element = wpb_xray.elem;
                }
            } catch (err) {
                exception_debugging(err);
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    recognition_output: function () {
        var obj_rect = "";
        if (this.object_sub_type === "") {
            obj_rect = this.element_rect.left + "," + this.element_rect.top + "," +
                      this.element_rect.right + "," + this.element_rect.bottom;
        } else {
            obj_rect = this.element_rect_str;
        }
        return ("epath|=|" + "" + delimiter +
                "type|=|" + this.object_type + delimiter +
                "rect|=|" + obj_rect + delimiter +
                "eep|=|" + this.eep + this.xray_path + delimiter +
                "name|=|" + "" + delimiter +
                "val|=|" + "" + delimiter +
                "safe|=|" + this.path_safe);
    }
});

var HTMLElementRecognition = new DGO.XRayHTMLElementRecognition();
// ---------------------------------------------------
var HTMLElementRerecognition = new DGO.BaseHTMLElementRerecognition();

DGO.UI5Effect = function () {
    DGO.Effect.call(this);
};
DGO.UI5Effect.prototype = new DGO.Effect();

extendObj(DGO.UI5Effect.prototype, {
    mouse_effect_handler: function (e) {
        try {
            e = e || event;
            if (!e || !e.target) return;

            if (e.type === "mouseover") {
                //console.log("mouseover effect");
                if (DgoEffect.overlay.active === false) return;
                var p = generate_xray_path(e.target, Help4R.RpickSelector().selector);  // xRay.js
                var target_pos = (p &amp;&amp; p.elem) ? p.elem.getBoundingClientRect() : e.target.getBoundingClientRect();

                var overlay_style = DgoEffect.get_overlay().style;
                overlay_style.cssText = _HELP4_CONTROL_CAPTURERECT_CSS + ((p &amp;&amp; p.safe === 1.0) ? _HELP4_SAFE_CSS : "");
                overlay_style.visibility = "";
                overlay_style.left = target_pos.left.toString() + "px";
                overlay_style.top = target_pos.top.toString() + "px";
                overlay_style.width = (target_pos.right - target_pos.left).toString() + "px";
                overlay_style.height = (target_pos.bottom - target_pos.top).toString() + "px";

                //console.log("over " + e.target.tagName + ":" + e.target.className + " pos: " + target_pos.left + "x" + target_pos.top + ((p &amp;&amp; p.elem) ? " (selector element)" : " (event target)"));
                //console.log("effect active: " + DgoEffect.overlay.active + " timestamp: " + DgoEffect.overlay.timestamp);
                //console.log("rule: " + p.rule.toString());
                //console.log("selector: " + Help4R.RpickSelector().name);   // xRay.js

                // prevent other mouseover effects
                e.cancelBubble = true;
            }
        } catch (err) { exception_debugging(err); console.log(err.stack); }
    }

});

var DgoEffect = DgoEffect || new DGO.UI5Effect();



// include file: script.js

var EepUtils = new DGO.BaseEepUtils();//DGO.ExtendedEepUtils();
var DgoEep = new DGO.BaseEep();
var DgoUtils = new DGO.Utils();
var DgoProcessing = new DGO.BaseProcessing();
var HTMLElementRerecognition = new DGO.BaseHTMLElementRerecognition();

DGO.GenericWebApp = function () {
    DGO.HTMLBasic.call(this);
}

DGO.GenericWebApp.prototype = new DGO.HTMLBasic();
extendObj(DGO.GenericWebApp.prototype, {
    check_handler: function (type) {    // DGO.profile.check_handler(type) replaces dgo_check_handler(type)

            return DgoUtils.is_in_array(type, DgoProfile.get_valid_roles()) ||
            DGO.HTMLBasic.prototype.check_handler.call(this, type);
    },
    convert_to_compat: function (type) {

        return DGO.HTMLBasic.prototype.convert_to_compat.call(this, type);
    },
    get_title: function () {
        var t = window.document.title;
        return t === 'about:blank'
            ? ''
            : t;
    }
});

var DgoProfile = new DGO.GenericWebApp();
DGO.GenericWebAppHTMLElementRecognition = function () {
    DGO.HtmlBasicHTMLElementRecognition.call(this);
};

DGO.GenericWebAppHTMLElementRecognition.prototype = new DGO.HtmlBasicHTMLElementRecognition();
var HTMLElementRecognition = new DGO.GenericWebAppHTMLElementRecognition();

</GlobalScript>
        </HTML3>
        <DIG generate_path="0" generate_triangle="1">
            <Settings>
                <CParams min_object_height="8" min_object_width="8">
                    <ClusterParams epsh="4" epsv="6" min_pts="2" max_cl_size="20"/>
                    <ClusterParams epsh="15" epsv="1" min_pts="1" max_cl_size="20"/>
                    <ClusterParams epsh="10" epsv="1" min_pts="10" max_cl_size="20"/>
                    <ClusterParams epsh="10" epsv="1" min_pts="11" max_cl_size="16"/>
                </CParams>
                <RParams max_gap="1" min_line_length="10" threshold="30"/>
                <CiParams circle_threshold="0.750000" inner_threshold="0.950000" outer_threshold="0.950000">
                    <RadiusRange min="6" max="7"/>
                </CiParams>
            </Settings>
            <PointAnalyzing all="0" analyze_width="50" analyze_height="250" merge_cross_objects="1"/>
        </DIG>
        <SAPB1 generate_path="1" analyze_point_timeout="3000" get_pagekey_timeout="7000"/>
        <GRAPHIC>
            <SupportedDesigns/>
        </GRAPHIC>
    </Global>
</CTHeader>